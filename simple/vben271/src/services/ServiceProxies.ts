/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import {ServiceProxyBase} from './ServiceProxyBase'
import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import  moment from 'moment';

export class AbpApiDefinitionServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param includeTypes (optional) 
     * @return Success
     */
    apiDefinition(includeTypes: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<ApplicationApiDescriptionModel> {
        let url_ = this.baseUrl + "/api/abp/api-definition?";
        if (includeTypes === null)
            throw new Error("The parameter 'includeTypes' cannot be null.");
        else if (includeTypes !== undefined)
            url_ += "IncludeTypes=" + encodeURIComponent("" + includeTypes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processApiDefinition(_response));
        });
    }

    protected processApiDefinition(response: AxiosResponse): Promise<ApplicationApiDescriptionModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationApiDescriptionModel.fromJS(resultData200);
            return Promise.resolve<ApplicationApiDescriptionModel>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationApiDescriptionModel>(null as any);
    }
}

export class AbpApplicationConfigurationServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    applicationConfiguration(  cancelToken?: CancelToken | undefined): Promise<ApplicationConfigurationDto> {
        let url_ = this.baseUrl + "/api/abp/application-configuration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processApplicationConfiguration(_response));
        });
    }

    protected processApplicationConfiguration(response: AxiosResponse): Promise<ApplicationConfigurationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationConfigurationDto.fromJS(resultData200);
            return Promise.resolve<ApplicationConfigurationDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationConfigurationDto>(null as any);
    }
}

export class AccountServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 登录
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginInput | undefined , cancelToken?: CancelToken | undefined): Promise<LoginOutput> {
        let url_ = this.baseUrl + "/api/app/account/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processLogin(_response));
        });
    }

    protected processLogin(response: AxiosResponse): Promise<LoginOutput> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LoginOutput.fromJS(resultData200);
            return Promise.resolve<LoginOutput>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LoginOutput>(null as any);
    }
}

export class AuditLogsServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 分页获取审计日志信息
     * @param body (optional) 
     * @return Success
     */
    page(body: PagingAuditLogListInput | undefined , cancelToken?: CancelToken | undefined): Promise<GetAuditLogPageListOutputPagedResultDto> {
        let url_ = this.baseUrl + "/AuditLogs/page";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPage(_response));
        });
    }

    protected processPage(response: AxiosResponse): Promise<GetAuditLogPageListOutputPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetAuditLogPageListOutputPagedResultDto.fromJS(resultData200);
            return Promise.resolve<GetAuditLogPageListOutputPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAuditLogPageListOutputPagedResultDto>(null as any);
    }
}

export class PermissionsServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 获取角色权限
     * @param body (optional) 
     * @return Success
     */
    tree(body: GetPermissionInput | undefined , cancelToken?: CancelToken | undefined): Promise<PermissionOutput> {
        let url_ = this.baseUrl + "/Permissions/tree";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processTree(_response));
        });
    }

    protected processTree(response: AxiosResponse): Promise<PermissionOutput> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PermissionOutput.fromJS(resultData200);
            return Promise.resolve<PermissionOutput>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PermissionOutput>(null as any);
    }

    /**
     * 更新角色
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateRolePermissionsInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Permissions/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class RolesServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 获取所有角色
     * @return Success
     */
    all(  cancelToken?: CancelToken | undefined): Promise<IdentityRoleDtoListResultDto> {
        let url_ = this.baseUrl + "/Roles/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAll(_response));
        });
    }

    protected processAll(response: AxiosResponse): Promise<IdentityRoleDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityRoleDtoListResultDto.fromJS(resultData200);
            return Promise.resolve<IdentityRoleDtoListResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleDtoListResultDto>(null as any);
    }

    /**
     * 分页获取角色
     * @param body (optional) 
     * @return Success
     */
    page(body: PagingRoleListInput | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityRoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/Roles/page";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPage(_response));
        });
    }

    protected processPage(response: AxiosResponse): Promise<IdentityRoleDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityRoleDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<IdentityRoleDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleDtoPagedResultDto>(null as any);
    }

    /**
     * 创建角色
     * @param body (optional) 
     * @return Success
     */
    create(body: IdentityRoleCreateDto | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/Roles/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreate(_response));
        });
    }

    protected processCreate(response: AxiosResponse): Promise<IdentityRoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityRoleDto.fromJS(resultData200);
            return Promise.resolve<IdentityRoleDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleDto>(null as any);
    }

    /**
     * 更新角色
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateRoleInput | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/Roles/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<IdentityRoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityRoleDto.fromJS(resultData200);
            return Promise.resolve<IdentityRoleDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleDto>(null as any);
    }

    /**
     * 删除角色
     * @param body (optional) 
     * @return Success
     */
    delete(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Roles/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDelete(_response));
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class SettingsServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 获取所有Setting
     * @return Success
     */
    all(  cancelToken?: CancelToken | undefined): Promise<SettingOutput[]> {
        let url_ = this.baseUrl + "/Settings/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAll(_response));
        });
    }

    protected processAll(response: AxiosResponse): Promise<SettingOutput[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SettingOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SettingOutput[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SettingOutput[]>(null as any);
    }

    /**
     * 更新Setting
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateSettingInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Settings/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class TenantsServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 通过名称获取租户信息
     * @param body (optional) 
     * @return Success
     */
    find(body: FindTenantByNameInput | undefined , cancelToken?: CancelToken | undefined): Promise<FindTenantResultDto> {
        let url_ = this.baseUrl + "/Tenants/find";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processFind(_response));
        });
    }

    protected processFind(response: AxiosResponse): Promise<FindTenantResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FindTenantResultDto.fromJS(resultData200);
            return Promise.resolve<FindTenantResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FindTenantResultDto>(null as any);
    }

    /**
     * 分页获取租户信息
     * @param body (optional) 
     * @return Success
     */
    page(body: PagingTenantInput | undefined , cancelToken?: CancelToken | undefined): Promise<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/Tenants/page";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPage(_response));
        });
    }

    protected processPage(response: AxiosResponse): Promise<TenantDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TenantDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<TenantDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TenantDtoPagedResultDto>(null as any);
    }

    /**
     * 创建租户
     * @param body (optional) 
     * @return Success
     */
    create(body: TenantCreateDto | undefined , cancelToken?: CancelToken | undefined): Promise<TenantDto> {
        let url_ = this.baseUrl + "/Tenants/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreate(_response));
        });
    }

    protected processCreate(response: AxiosResponse): Promise<TenantDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TenantDto.fromJS(resultData200);
            return Promise.resolve<TenantDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TenantDto>(null as any);
    }

    /**
     * 更新租户
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateTenantInput | undefined , cancelToken?: CancelToken | undefined): Promise<TenantDto> {
        let url_ = this.baseUrl + "/Tenants/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<TenantDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TenantDto.fromJS(resultData200);
            return Promise.resolve<TenantDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TenantDto>(null as any);
    }

    /**
     * 删除租户
     * @param body (optional) 
     * @return Success
     */
    delete(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Tenants/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDelete(_response));
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 获取租户连接字符串
     * @param body (optional) 
     * @return Success
     */
    getConnectionString(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/Tenants/getConnectionString";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetConnectionString(_response));
        });
    }

    protected processGetConnectionString(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * 更新租户连接字符串
     * @param body (optional) 
     * @return Success
     */
    updateConnectionString(body: UpdateConnectionStringInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Tenants/updateConnectionString";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdateConnectionString(_response));
        });
    }

    protected processUpdateConnectionString(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 删除租户连接字符串
     * @param body (optional) 
     * @return Success
     */
    deleteConnectionString(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Tenants/deleteConnectionString";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDeleteConnectionString(_response));
        });
    }

    protected processDeleteConnectionString(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class UsersServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 分页获取用户信息
     * @param body (optional) 
     * @return Success
     */
    page(body: PagingUserListInput | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityUserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/Users/page";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPage(_response));
        });
    }

    protected processPage(response: AxiosResponse): Promise<IdentityUserDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDtoPagedResultDto>(null as any);
    }

    /**
     * 导出用户列表
     * @param body (optional) 
     * @return Success
     */
    export(body: PagingUserListInput | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/Users/export";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processExport(_response));
        });
    }

    protected processExport(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * 创建用户
     * @param body (optional) 
     * @return Success
     */
    create(body: IdentityUserCreateDto | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/Users/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreate(_response));
        });
    }

    protected processCreate(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * 编辑用户
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateUserInput | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/Users/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * 删除用户
     * @param body (optional) 
     * @return Success
     */
    delete(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Users/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDelete(_response));
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 获取用户角色信息
     * @param body (optional) 
     * @return Success
     */
    role(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityRoleDtoListResultDto> {
        let url_ = this.baseUrl + "/Users/role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRole(_response));
        });
    }

    protected processRole(response: AxiosResponse): Promise<IdentityRoleDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityRoleDtoListResultDto.fromJS(resultData200);
            return Promise.resolve<IdentityRoleDtoListResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleDtoListResultDto>(null as any);
    }

    /**
     * 修改当前用户密码
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/Users/changePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processChangePassword(_response));
        });
    }

    protected processChangePassword(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * 锁定用户
     * @param body (optional) 
     * @return Success
     */
    lock(body: LockUserInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Users/lock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processLock(_response));
        });
    }

    protected processLock(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AbpLoginResult implements IAbpLoginResult {
    result!: LoginResultType;
    readonly description!: string | undefined;

    constructor(data?: IAbpLoginResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
            (<any>this).description = _data["description"];
        }
    }

    static fromJS(data: any): AbpLoginResult {
        data = typeof data === 'object' ? data : {};
        let result = new AbpLoginResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["description"] = this.description;
        return data;
    }
}

export interface IAbpLoginResult {
    result: LoginResultType;
    description: string | undefined;
}

export class ActionApiDescriptionModel implements IActionApiDescriptionModel {
    uniqueName!: string | undefined;
    name!: string | undefined;
    httpMethod!: string | undefined;
    url!: string | undefined;
    supportedVersions!: string[] | undefined;
    parametersOnMethod!: MethodParameterApiDescriptionModel[] | undefined;
    parameters!: ParameterApiDescriptionModel[] | undefined;
    returnValue!: ReturnValueApiDescriptionModel;
    allowAnonymous!: boolean | undefined;
    implementFrom!: string | undefined;

    constructor(data?: IActionApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uniqueName = _data["uniqueName"];
            this.name = _data["name"];
            this.httpMethod = _data["httpMethod"];
            this.url = _data["url"];
            if (Array.isArray(_data["supportedVersions"])) {
                this.supportedVersions = [] as any;
                for (let item of _data["supportedVersions"])
                    this.supportedVersions!.push(item);
            }
            if (Array.isArray(_data["parametersOnMethod"])) {
                this.parametersOnMethod = [] as any;
                for (let item of _data["parametersOnMethod"])
                    this.parametersOnMethod!.push(MethodParameterApiDescriptionModel.fromJS(item));
            }
            if (Array.isArray(_data["parameters"])) {
                this.parameters = [] as any;
                for (let item of _data["parameters"])
                    this.parameters!.push(ParameterApiDescriptionModel.fromJS(item));
            }
            this.returnValue = _data["returnValue"] ? ReturnValueApiDescriptionModel.fromJS(_data["returnValue"]) : <any>undefined;
            this.allowAnonymous = _data["allowAnonymous"];
            this.implementFrom = _data["implementFrom"];
        }
    }

    static fromJS(data: any): ActionApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActionApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueName"] = this.uniqueName;
        data["name"] = this.name;
        data["httpMethod"] = this.httpMethod;
        data["url"] = this.url;
        if (Array.isArray(this.supportedVersions)) {
            data["supportedVersions"] = [];
            for (let item of this.supportedVersions)
                data["supportedVersions"].push(item);
        }
        if (Array.isArray(this.parametersOnMethod)) {
            data["parametersOnMethod"] = [];
            for (let item of this.parametersOnMethod)
                data["parametersOnMethod"].push(item.toJSON());
        }
        if (Array.isArray(this.parameters)) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        data["returnValue"] = this.returnValue ? this.returnValue.toJSON() : <any>undefined;
        data["allowAnonymous"] = this.allowAnonymous;
        data["implementFrom"] = this.implementFrom;
        return data;
    }
}

export interface IActionApiDescriptionModel {
    uniqueName: string | undefined;
    name: string | undefined;
    httpMethod: string | undefined;
    url: string | undefined;
    supportedVersions: string[] | undefined;
    parametersOnMethod: MethodParameterApiDescriptionModel[] | undefined;
    parameters: ParameterApiDescriptionModel[] | undefined;
    returnValue: ReturnValueApiDescriptionModel;
    allowAnonymous: boolean | undefined;
    implementFrom: string | undefined;
}

export class AggregateRouteConfig implements IAggregateRouteConfig {
    routeKey!: string | undefined;
    parameter!: string | undefined;
    jsonPath!: string | undefined;

    constructor(data?: IAggregateRouteConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.routeKey = _data["routeKey"];
            this.parameter = _data["parameter"];
            this.jsonPath = _data["jsonPath"];
        }
    }

    static fromJS(data: any): AggregateRouteConfig {
        data = typeof data === 'object' ? data : {};
        let result = new AggregateRouteConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["routeKey"] = this.routeKey;
        data["parameter"] = this.parameter;
        data["jsonPath"] = this.jsonPath;
        return data;
    }
}

export interface IAggregateRouteConfig {
    routeKey: string | undefined;
    parameter: string | undefined;
    jsonPath: string | undefined;
}

export class ApplicationApiDescriptionModel implements IApplicationApiDescriptionModel {
    modules!: { [key: string]: ModuleApiDescriptionModel; } | undefined;
    types!: { [key: string]: TypeApiDescriptionModel; } | undefined;

    constructor(data?: IApplicationApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["modules"]) {
                this.modules = {} as any;
                for (let key in _data["modules"]) {
                    if (_data["modules"].hasOwnProperty(key))
                        (<any>this.modules)![key] = _data["modules"][key] ? ModuleApiDescriptionModel.fromJS(_data["modules"][key]) : new ModuleApiDescriptionModel();
                }
            }
            if (_data["types"]) {
                this.types = {} as any;
                for (let key in _data["types"]) {
                    if (_data["types"].hasOwnProperty(key))
                        (<any>this.types)![key] = _data["types"][key] ? TypeApiDescriptionModel.fromJS(_data["types"][key]) : new TypeApiDescriptionModel();
                }
            }
        }
    }

    static fromJS(data: any): ApplicationApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.modules) {
            data["modules"] = {};
            for (let key in this.modules) {
                if (this.modules.hasOwnProperty(key))
                    (<any>data["modules"])[key] = this.modules[key] ? this.modules[key].toJSON() : <any>undefined;
            }
        }
        if (this.types) {
            data["types"] = {};
            for (let key in this.types) {
                if (this.types.hasOwnProperty(key))
                    (<any>data["types"])[key] = this.types[key] ? this.types[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IApplicationApiDescriptionModel {
    modules: { [key: string]: ModuleApiDescriptionModel; } | undefined;
    types: { [key: string]: TypeApiDescriptionModel; } | undefined;
}

export class ApplicationAuthConfigurationDto implements IApplicationAuthConfigurationDto {
    policies!: { [key: string]: boolean; } | undefined;
    grantedPolicies!: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationAuthConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["policies"]) {
                this.policies = {} as any;
                for (let key in _data["policies"]) {
                    if (_data["policies"].hasOwnProperty(key))
                        (<any>this.policies)![key] = _data["policies"][key];
                }
            }
            if (_data["grantedPolicies"]) {
                this.grantedPolicies = {} as any;
                for (let key in _data["grantedPolicies"]) {
                    if (_data["grantedPolicies"].hasOwnProperty(key))
                        (<any>this.grantedPolicies)![key] = _data["grantedPolicies"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationAuthConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationAuthConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.policies) {
            data["policies"] = {};
            for (let key in this.policies) {
                if (this.policies.hasOwnProperty(key))
                    (<any>data["policies"])[key] = this.policies[key];
            }
        }
        if (this.grantedPolicies) {
            data["grantedPolicies"] = {};
            for (let key in this.grantedPolicies) {
                if (this.grantedPolicies.hasOwnProperty(key))
                    (<any>data["grantedPolicies"])[key] = this.grantedPolicies[key];
            }
        }
        return data;
    }
}

export interface IApplicationAuthConfigurationDto {
    policies: { [key: string]: boolean; } | undefined;
    grantedPolicies: { [key: string]: boolean; } | undefined;
}

export class ApplicationConfigurationDto implements IApplicationConfigurationDto {
    localization!: ApplicationLocalizationConfigurationDto;
    auth!: ApplicationAuthConfigurationDto;
    setting!: ApplicationSettingConfigurationDto;
    currentUser!: CurrentUserDto;
    features!: ApplicationFeatureConfigurationDto;
    multiTenancy!: MultiTenancyInfoDto;
    currentTenant!: CurrentTenantDto;
    timing!: TimingDto;
    clock!: ClockDto;
    objectExtensions!: ObjectExtensionsDto;

    constructor(data?: IApplicationConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.localization = _data["localization"] ? ApplicationLocalizationConfigurationDto.fromJS(_data["localization"]) : <any>undefined;
            this.auth = _data["auth"] ? ApplicationAuthConfigurationDto.fromJS(_data["auth"]) : <any>undefined;
            this.setting = _data["setting"] ? ApplicationSettingConfigurationDto.fromJS(_data["setting"]) : <any>undefined;
            this.currentUser = _data["currentUser"] ? CurrentUserDto.fromJS(_data["currentUser"]) : <any>undefined;
            this.features = _data["features"] ? ApplicationFeatureConfigurationDto.fromJS(_data["features"]) : <any>undefined;
            this.multiTenancy = _data["multiTenancy"] ? MultiTenancyInfoDto.fromJS(_data["multiTenancy"]) : <any>undefined;
            this.currentTenant = _data["currentTenant"] ? CurrentTenantDto.fromJS(_data["currentTenant"]) : <any>undefined;
            this.timing = _data["timing"] ? TimingDto.fromJS(_data["timing"]) : <any>undefined;
            this.clock = _data["clock"] ? ClockDto.fromJS(_data["clock"]) : <any>undefined;
            this.objectExtensions = _data["objectExtensions"] ? ObjectExtensionsDto.fromJS(_data["objectExtensions"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localization"] = this.localization ? this.localization.toJSON() : <any>undefined;
        data["auth"] = this.auth ? this.auth.toJSON() : <any>undefined;
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        data["currentUser"] = this.currentUser ? this.currentUser.toJSON() : <any>undefined;
        data["features"] = this.features ? this.features.toJSON() : <any>undefined;
        data["multiTenancy"] = this.multiTenancy ? this.multiTenancy.toJSON() : <any>undefined;
        data["currentTenant"] = this.currentTenant ? this.currentTenant.toJSON() : <any>undefined;
        data["timing"] = this.timing ? this.timing.toJSON() : <any>undefined;
        data["clock"] = this.clock ? this.clock.toJSON() : <any>undefined;
        data["objectExtensions"] = this.objectExtensions ? this.objectExtensions.toJSON() : <any>undefined;
        return data;
    }
}

export interface IApplicationConfigurationDto {
    localization: ApplicationLocalizationConfigurationDto;
    auth: ApplicationAuthConfigurationDto;
    setting: ApplicationSettingConfigurationDto;
    currentUser: CurrentUserDto;
    features: ApplicationFeatureConfigurationDto;
    multiTenancy: MultiTenancyInfoDto;
    currentTenant: CurrentTenantDto;
    timing: TimingDto;
    clock: ClockDto;
    objectExtensions: ObjectExtensionsDto;
}

export class ApplicationFeatureConfigurationDto implements IApplicationFeatureConfigurationDto {
    values!: { [key: string]: string; } | undefined;

    constructor(data?: IApplicationFeatureConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationFeatureConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationFeatureConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = this.values[key];
            }
        }
        return data;
    }
}

export interface IApplicationFeatureConfigurationDto {
    values: { [key: string]: string; } | undefined;
}

export class ApplicationLocalizationConfigurationDto implements IApplicationLocalizationConfigurationDto {
    values!: { [key: string]: { [key: string]: string; }; } | undefined;
    languages!: LanguageInfo[] | undefined;
    currentCulture!: CurrentCultureDto;
    defaultResourceName!: string | undefined;
    languagesMap!: { [key: string]: NameValue[]; } | undefined;
    languageFilesMap!: { [key: string]: NameValue[]; } | undefined;

    constructor(data?: IApplicationLocalizationConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key] !== undefined ? _data["values"][key] : {};
                }
            }
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(LanguageInfo.fromJS(item));
            }
            this.currentCulture = _data["currentCulture"] ? CurrentCultureDto.fromJS(_data["currentCulture"]) : <any>undefined;
            this.defaultResourceName = _data["defaultResourceName"];
            if (_data["languagesMap"]) {
                this.languagesMap = {} as any;
                for (let key in _data["languagesMap"]) {
                    if (_data["languagesMap"].hasOwnProperty(key))
                        (<any>this.languagesMap)![key] = _data["languagesMap"][key] ? _data["languagesMap"][key].map((i: any) => NameValue.fromJS(i)) : [];
                }
            }
            if (_data["languageFilesMap"]) {
                this.languageFilesMap = {} as any;
                for (let key in _data["languageFilesMap"]) {
                    if (_data["languageFilesMap"].hasOwnProperty(key))
                        (<any>this.languageFilesMap)![key] = _data["languageFilesMap"][key] ? _data["languageFilesMap"][key].map((i: any) => NameValue.fromJS(i)) : [];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationLocalizationConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLocalizationConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = this.values[key];
            }
        }
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        data["currentCulture"] = this.currentCulture ? this.currentCulture.toJSON() : <any>undefined;
        data["defaultResourceName"] = this.defaultResourceName;
        if (this.languagesMap) {
            data["languagesMap"] = {};
            for (let key in this.languagesMap) {
                if (this.languagesMap.hasOwnProperty(key))
                    (<any>data["languagesMap"])[key] = this.languagesMap[key];
            }
        }
        if (this.languageFilesMap) {
            data["languageFilesMap"] = {};
            for (let key in this.languageFilesMap) {
                if (this.languageFilesMap.hasOwnProperty(key))
                    (<any>data["languageFilesMap"])[key] = this.languageFilesMap[key];
            }
        }
        return data;
    }
}

export interface IApplicationLocalizationConfigurationDto {
    values: { [key: string]: { [key: string]: string; }; } | undefined;
    languages: LanguageInfo[] | undefined;
    currentCulture: CurrentCultureDto;
    defaultResourceName: string | undefined;
    languagesMap: { [key: string]: NameValue[]; } | undefined;
    languageFilesMap: { [key: string]: NameValue[]; } | undefined;
}

export class ApplicationSettingConfigurationDto implements IApplicationSettingConfigurationDto {
    values!: { [key: string]: string; } | undefined;

    constructor(data?: IApplicationSettingConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationSettingConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationSettingConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = this.values[key];
            }
        }
        return data;
    }
}

export interface IApplicationSettingConfigurationDto {
    values: { [key: string]: string; } | undefined;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword!: string | undefined;
    newPassword!: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordInput {
    currentPassword: string | undefined;
    newPassword: string;
}

export class ClockDto implements IClockDto {
    kind!: string | undefined;

    constructor(data?: IClockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kind = _data["kind"];
        }
    }

    static fromJS(data: any): ClockDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this.kind;
        return data;
    }
}

export interface IClockDto {
    kind: string | undefined;
}

export class ControllerApiDescriptionModel implements IControllerApiDescriptionModel {
    controllerName!: string | undefined;
    controllerGroupName!: string | undefined;
    isRemoteService!: boolean;
    apiVersion!: string | undefined;
    type!: string | undefined;
    interfaces!: ControllerInterfaceApiDescriptionModel[] | undefined;
    actions!: { [key: string]: ActionApiDescriptionModel; } | undefined;

    constructor(data?: IControllerApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.controllerName = _data["controllerName"];
            this.controllerGroupName = _data["controllerGroupName"];
            this.isRemoteService = _data["isRemoteService"];
            this.apiVersion = _data["apiVersion"];
            this.type = _data["type"];
            if (Array.isArray(_data["interfaces"])) {
                this.interfaces = [] as any;
                for (let item of _data["interfaces"])
                    this.interfaces!.push(ControllerInterfaceApiDescriptionModel.fromJS(item));
            }
            if (_data["actions"]) {
                this.actions = {} as any;
                for (let key in _data["actions"]) {
                    if (_data["actions"].hasOwnProperty(key))
                        (<any>this.actions)![key] = _data["actions"][key] ? ActionApiDescriptionModel.fromJS(_data["actions"][key]) : new ActionApiDescriptionModel();
                }
            }
        }
    }

    static fromJS(data: any): ControllerApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["controllerName"] = this.controllerName;
        data["controllerGroupName"] = this.controllerGroupName;
        data["isRemoteService"] = this.isRemoteService;
        data["apiVersion"] = this.apiVersion;
        data["type"] = this.type;
        if (Array.isArray(this.interfaces)) {
            data["interfaces"] = [];
            for (let item of this.interfaces)
                data["interfaces"].push(item.toJSON());
        }
        if (this.actions) {
            data["actions"] = {};
            for (let key in this.actions) {
                if (this.actions.hasOwnProperty(key))
                    (<any>data["actions"])[key] = this.actions[key] ? this.actions[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IControllerApiDescriptionModel {
    controllerName: string | undefined;
    controllerGroupName: string | undefined;
    isRemoteService: boolean;
    apiVersion: string | undefined;
    type: string | undefined;
    interfaces: ControllerInterfaceApiDescriptionModel[] | undefined;
    actions: { [key: string]: ActionApiDescriptionModel; } | undefined;
}

export class ControllerInterfaceApiDescriptionModel implements IControllerInterfaceApiDescriptionModel {
    type!: string | undefined;

    constructor(data?: IControllerInterfaceApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ControllerInterfaceApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerInterfaceApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        return data;
    }
}

export interface IControllerInterfaceApiDescriptionModel {
    type: string | undefined;
}

export class CurrentCultureDto implements ICurrentCultureDto {
    displayName!: string | undefined;
    englishName!: string | undefined;
    threeLetterIsoLanguageName!: string | undefined;
    twoLetterIsoLanguageName!: string | undefined;
    isRightToLeft!: boolean;
    cultureName!: string | undefined;
    name!: string | undefined;
    nativeName!: string | undefined;
    dateTimeFormat!: DateTimeFormatDto;

    constructor(data?: ICurrentCultureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.englishName = _data["englishName"];
            this.threeLetterIsoLanguageName = _data["threeLetterIsoLanguageName"];
            this.twoLetterIsoLanguageName = _data["twoLetterIsoLanguageName"];
            this.isRightToLeft = _data["isRightToLeft"];
            this.cultureName = _data["cultureName"];
            this.name = _data["name"];
            this.nativeName = _data["nativeName"];
            this.dateTimeFormat = _data["dateTimeFormat"] ? DateTimeFormatDto.fromJS(_data["dateTimeFormat"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CurrentCultureDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentCultureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["englishName"] = this.englishName;
        data["threeLetterIsoLanguageName"] = this.threeLetterIsoLanguageName;
        data["twoLetterIsoLanguageName"] = this.twoLetterIsoLanguageName;
        data["isRightToLeft"] = this.isRightToLeft;
        data["cultureName"] = this.cultureName;
        data["name"] = this.name;
        data["nativeName"] = this.nativeName;
        data["dateTimeFormat"] = this.dateTimeFormat ? this.dateTimeFormat.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICurrentCultureDto {
    displayName: string | undefined;
    englishName: string | undefined;
    threeLetterIsoLanguageName: string | undefined;
    twoLetterIsoLanguageName: string | undefined;
    isRightToLeft: boolean;
    cultureName: string | undefined;
    name: string | undefined;
    nativeName: string | undefined;
    dateTimeFormat: DateTimeFormatDto;
}

export class CurrentTenantDto implements ICurrentTenantDto {
    id!: string | undefined;
    name!: string | undefined;
    isAvailable!: boolean;

    constructor(data?: ICurrentTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): CurrentTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface ICurrentTenantDto {
    id: string | undefined;
    name: string | undefined;
    isAvailable: boolean;
}

export class CurrentUserDto implements ICurrentUserDto {
    isAuthenticated!: boolean;
    id!: string | undefined;
    tenantId!: string | undefined;
    impersonatorUserId!: string | undefined;
    impersonatorTenantId!: string | undefined;
    impersonatorUserName!: string | undefined;
    impersonatorTenantName!: string | undefined;
    userName!: string | undefined;
    name!: string | undefined;
    surName!: string | undefined;
    email!: string | undefined;
    emailVerified!: boolean;
    phoneNumber!: string | undefined;
    phoneNumberVerified!: boolean;
    roles!: string[] | undefined;

    constructor(data?: ICurrentUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAuthenticated = _data["isAuthenticated"];
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.impersonatorTenantId = _data["impersonatorTenantId"];
            this.impersonatorUserName = _data["impersonatorUserName"];
            this.impersonatorTenantName = _data["impersonatorTenantName"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surName = _data["surName"];
            this.email = _data["email"];
            this.emailVerified = _data["emailVerified"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberVerified = _data["phoneNumberVerified"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CurrentUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAuthenticated"] = this.isAuthenticated;
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserName"] = this.impersonatorUserName;
        data["impersonatorTenantName"] = this.impersonatorTenantName;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surName"] = this.surName;
        data["email"] = this.email;
        data["emailVerified"] = this.emailVerified;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberVerified"] = this.phoneNumberVerified;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface ICurrentUserDto {
    isAuthenticated: boolean;
    id: string | undefined;
    tenantId: string | undefined;
    impersonatorUserId: string | undefined;
    impersonatorTenantId: string | undefined;
    impersonatorUserName: string | undefined;
    impersonatorTenantName: string | undefined;
    userName: string | undefined;
    name: string | undefined;
    surName: string | undefined;
    email: string | undefined;
    emailVerified: boolean;
    phoneNumber: string | undefined;
    phoneNumberVerified: boolean;
    roles: string[] | undefined;
}

export class DateTimeFormatDto implements IDateTimeFormatDto {
    calendarAlgorithmType!: string | undefined;
    dateTimeFormatLong!: string | undefined;
    shortDatePattern!: string | undefined;
    fullDateTimePattern!: string | undefined;
    dateSeparator!: string | undefined;
    shortTimePattern!: string | undefined;
    longTimePattern!: string | undefined;

    constructor(data?: IDateTimeFormatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.calendarAlgorithmType = _data["calendarAlgorithmType"];
            this.dateTimeFormatLong = _data["dateTimeFormatLong"];
            this.shortDatePattern = _data["shortDatePattern"];
            this.fullDateTimePattern = _data["fullDateTimePattern"];
            this.dateSeparator = _data["dateSeparator"];
            this.shortTimePattern = _data["shortTimePattern"];
            this.longTimePattern = _data["longTimePattern"];
        }
    }

    static fromJS(data: any): DateTimeFormatDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeFormatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["calendarAlgorithmType"] = this.calendarAlgorithmType;
        data["dateTimeFormatLong"] = this.dateTimeFormatLong;
        data["shortDatePattern"] = this.shortDatePattern;
        data["fullDateTimePattern"] = this.fullDateTimePattern;
        data["dateSeparator"] = this.dateSeparator;
        data["shortTimePattern"] = this.shortTimePattern;
        data["longTimePattern"] = this.longTimePattern;
        return data;
    }
}

export interface IDateTimeFormatDto {
    calendarAlgorithmType: string | undefined;
    dateTimeFormatLong: string | undefined;
    shortDatePattern: string | undefined;
    fullDateTimePattern: string | undefined;
    dateSeparator: string | undefined;
    shortTimePattern: string | undefined;
    longTimePattern: string | undefined;
}

export class EmailSettingsDto implements IEmailSettingsDto {
    smtpHost!: string | undefined;
    smtpPort!: number;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean;
    smtpUseDefaultCredentials!: boolean;
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;

    constructor(data?: IEmailSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
        }
    }

    static fromJS(data: any): EmailSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        return data;
    }
}

export interface IEmailSettingsDto {
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
}

export class EntityExtensionDto implements IEntityExtensionDto {
    properties!: { [key: string]: ExtensionPropertyDto; } | undefined;
    configuration!: { [key: string]: any; } | undefined;

    constructor(data?: IEntityExtensionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? ExtensionPropertyDto.fromJS(_data["properties"][key]) : new ExtensionPropertyDto();
                }
            }
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
        }
    }

    static fromJS(data: any): EntityExtensionDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityExtensionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = this.configuration[key];
            }
        }
        return data;
    }
}

export interface IEntityExtensionDto {
    properties: { [key: string]: ExtensionPropertyDto; } | undefined;
    configuration: { [key: string]: any; } | undefined;
}

export class ExtensionEnumDto implements IExtensionEnumDto {
    fields!: ExtensionEnumFieldDto[] | undefined;
    localizationResource!: string | undefined;

    constructor(data?: IExtensionEnumDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(ExtensionEnumFieldDto.fromJS(item));
            }
            this.localizationResource = _data["localizationResource"];
        }
    }

    static fromJS(data: any): ExtensionEnumDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionEnumDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        data["localizationResource"] = this.localizationResource;
        return data;
    }
}

export interface IExtensionEnumDto {
    fields: ExtensionEnumFieldDto[] | undefined;
    localizationResource: string | undefined;
}

export class ExtensionEnumFieldDto implements IExtensionEnumFieldDto {
    name!: string | undefined;
    value!: any | undefined;

    constructor(data?: IExtensionEnumFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ExtensionEnumFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionEnumFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IExtensionEnumFieldDto {
    name: string | undefined;
    value: any | undefined;
}

export class ExtensionPropertyApiCreateDto implements IExtensionPropertyApiCreateDto {
    isAvailable!: boolean;

    constructor(data?: IExtensionPropertyApiCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): ExtensionPropertyApiCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface IExtensionPropertyApiCreateDto {
    isAvailable: boolean;
}

export class ExtensionPropertyApiDto implements IExtensionPropertyApiDto {
    onGet!: ExtensionPropertyApiGetDto;
    onCreate!: ExtensionPropertyApiCreateDto;
    onUpdate!: ExtensionPropertyApiUpdateDto;

    constructor(data?: IExtensionPropertyApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onGet = _data["onGet"] ? ExtensionPropertyApiGetDto.fromJS(_data["onGet"]) : <any>undefined;
            this.onCreate = _data["onCreate"] ? ExtensionPropertyApiCreateDto.fromJS(_data["onCreate"]) : <any>undefined;
            this.onUpdate = _data["onUpdate"] ? ExtensionPropertyApiUpdateDto.fromJS(_data["onUpdate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExtensionPropertyApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onGet"] = this.onGet ? this.onGet.toJSON() : <any>undefined;
        data["onCreate"] = this.onCreate ? this.onCreate.toJSON() : <any>undefined;
        data["onUpdate"] = this.onUpdate ? this.onUpdate.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExtensionPropertyApiDto {
    onGet: ExtensionPropertyApiGetDto;
    onCreate: ExtensionPropertyApiCreateDto;
    onUpdate: ExtensionPropertyApiUpdateDto;
}

export class ExtensionPropertyApiGetDto implements IExtensionPropertyApiGetDto {
    isAvailable!: boolean;

    constructor(data?: IExtensionPropertyApiGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): ExtensionPropertyApiGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface IExtensionPropertyApiGetDto {
    isAvailable: boolean;
}

export class ExtensionPropertyApiUpdateDto implements IExtensionPropertyApiUpdateDto {
    isAvailable!: boolean;

    constructor(data?: IExtensionPropertyApiUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): ExtensionPropertyApiUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface IExtensionPropertyApiUpdateDto {
    isAvailable: boolean;
}

export class ExtensionPropertyAttributeDto implements IExtensionPropertyAttributeDto {
    typeSimple!: string | undefined;
    config!: { [key: string]: any; } | undefined;

    constructor(data?: IExtensionPropertyAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeSimple = _data["typeSimple"];
            if (_data["config"]) {
                this.config = {} as any;
                for (let key in _data["config"]) {
                    if (_data["config"].hasOwnProperty(key))
                        (<any>this.config)![key] = _data["config"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExtensionPropertyAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeSimple"] = this.typeSimple;
        if (this.config) {
            data["config"] = {};
            for (let key in this.config) {
                if (this.config.hasOwnProperty(key))
                    (<any>data["config"])[key] = this.config[key];
            }
        }
        return data;
    }
}

export interface IExtensionPropertyAttributeDto {
    typeSimple: string | undefined;
    config: { [key: string]: any; } | undefined;
}

export class ExtensionPropertyDto implements IExtensionPropertyDto {
    type!: string | undefined;
    typeSimple!: string | undefined;
    displayName!: LocalizableStringDto;
    api!: ExtensionPropertyApiDto;
    ui!: ExtensionPropertyUiDto;
    attributes!: ExtensionPropertyAttributeDto[] | undefined;
    configuration!: { [key: string]: any; } | undefined;
    defaultValue!: any | undefined;

    constructor(data?: IExtensionPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
            this.displayName = _data["displayName"] ? LocalizableStringDto.fromJS(_data["displayName"]) : <any>undefined;
            this.api = _data["api"] ? ExtensionPropertyApiDto.fromJS(_data["api"]) : <any>undefined;
            this.ui = _data["ui"] ? ExtensionPropertyUiDto.fromJS(_data["ui"]) : <any>undefined;
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(ExtensionPropertyAttributeDto.fromJS(item));
            }
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
            this.defaultValue = _data["defaultValue"];
        }
    }

    static fromJS(data: any): ExtensionPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        data["displayName"] = this.displayName ? this.displayName.toJSON() : <any>undefined;
        data["api"] = this.api ? this.api.toJSON() : <any>undefined;
        data["ui"] = this.ui ? this.ui.toJSON() : <any>undefined;
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = this.configuration[key];
            }
        }
        data["defaultValue"] = this.defaultValue;
        return data;
    }
}

export interface IExtensionPropertyDto {
    type: string | undefined;
    typeSimple: string | undefined;
    displayName: LocalizableStringDto;
    api: ExtensionPropertyApiDto;
    ui: ExtensionPropertyUiDto;
    attributes: ExtensionPropertyAttributeDto[] | undefined;
    configuration: { [key: string]: any; } | undefined;
    defaultValue: any | undefined;
}

export class ExtensionPropertyUiDto implements IExtensionPropertyUiDto {
    onTable!: ExtensionPropertyUiTableDto;
    onCreateForm!: ExtensionPropertyUiFormDto;
    onEditForm!: ExtensionPropertyUiFormDto;
    lookup!: ExtensionPropertyUiLookupDto;

    constructor(data?: IExtensionPropertyUiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onTable = _data["onTable"] ? ExtensionPropertyUiTableDto.fromJS(_data["onTable"]) : <any>undefined;
            this.onCreateForm = _data["onCreateForm"] ? ExtensionPropertyUiFormDto.fromJS(_data["onCreateForm"]) : <any>undefined;
            this.onEditForm = _data["onEditForm"] ? ExtensionPropertyUiFormDto.fromJS(_data["onEditForm"]) : <any>undefined;
            this.lookup = _data["lookup"] ? ExtensionPropertyUiLookupDto.fromJS(_data["lookup"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExtensionPropertyUiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onTable"] = this.onTable ? this.onTable.toJSON() : <any>undefined;
        data["onCreateForm"] = this.onCreateForm ? this.onCreateForm.toJSON() : <any>undefined;
        data["onEditForm"] = this.onEditForm ? this.onEditForm.toJSON() : <any>undefined;
        data["lookup"] = this.lookup ? this.lookup.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExtensionPropertyUiDto {
    onTable: ExtensionPropertyUiTableDto;
    onCreateForm: ExtensionPropertyUiFormDto;
    onEditForm: ExtensionPropertyUiFormDto;
    lookup: ExtensionPropertyUiLookupDto;
}

export class ExtensionPropertyUiFormDto implements IExtensionPropertyUiFormDto {
    isVisible!: boolean;

    constructor(data?: IExtensionPropertyUiFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isVisible = _data["isVisible"];
        }
    }

    static fromJS(data: any): ExtensionPropertyUiFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isVisible"] = this.isVisible;
        return data;
    }
}

export interface IExtensionPropertyUiFormDto {
    isVisible: boolean;
}

export class ExtensionPropertyUiLookupDto implements IExtensionPropertyUiLookupDto {
    url!: string | undefined;
    resultListPropertyName!: string | undefined;
    displayPropertyName!: string | undefined;
    valuePropertyName!: string | undefined;
    filterParamName!: string | undefined;

    constructor(data?: IExtensionPropertyUiLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.resultListPropertyName = _data["resultListPropertyName"];
            this.displayPropertyName = _data["displayPropertyName"];
            this.valuePropertyName = _data["valuePropertyName"];
            this.filterParamName = _data["filterParamName"];
        }
    }

    static fromJS(data: any): ExtensionPropertyUiLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["resultListPropertyName"] = this.resultListPropertyName;
        data["displayPropertyName"] = this.displayPropertyName;
        data["valuePropertyName"] = this.valuePropertyName;
        data["filterParamName"] = this.filterParamName;
        return data;
    }
}

export interface IExtensionPropertyUiLookupDto {
    url: string | undefined;
    resultListPropertyName: string | undefined;
    displayPropertyName: string | undefined;
    valuePropertyName: string | undefined;
    filterParamName: string | undefined;
}

export class ExtensionPropertyUiTableDto implements IExtensionPropertyUiTableDto {
    isVisible!: boolean;

    constructor(data?: IExtensionPropertyUiTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isVisible = _data["isVisible"];
        }
    }

    static fromJS(data: any): ExtensionPropertyUiTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isVisible"] = this.isVisible;
        return data;
    }
}

export interface IExtensionPropertyUiTableDto {
    isVisible: boolean;
}

export class FeatureDto implements IFeatureDto {
    name!: string | undefined;
    displayName!: string | undefined;
    value!: string | undefined;
    provider!: FeatureProviderDto;
    description!: string | undefined;
    valueType!: IStringValueType;
    depth!: number;
    parentName!: string | undefined;

    constructor(data?: IFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.value = _data["value"];
            this.provider = _data["provider"] ? FeatureProviderDto.fromJS(_data["provider"]) : <any>undefined;
            this.description = _data["description"];
            this.valueType = _data["valueType"] ? IStringValueType.fromJS(_data["valueType"]) : <any>undefined;
            this.depth = _data["depth"];
            this.parentName = _data["parentName"];
        }
    }

    static fromJS(data: any): FeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["value"] = this.value;
        data["provider"] = this.provider ? this.provider.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["valueType"] = this.valueType ? this.valueType.toJSON() : <any>undefined;
        data["depth"] = this.depth;
        data["parentName"] = this.parentName;
        return data;
    }
}

export interface IFeatureDto {
    name: string | undefined;
    displayName: string | undefined;
    value: string | undefined;
    provider: FeatureProviderDto;
    description: string | undefined;
    valueType: IStringValueType;
    depth: number;
    parentName: string | undefined;
}

export class FeatureGroupDto implements IFeatureGroupDto {
    name!: string | undefined;
    displayName!: string | undefined;
    features!: FeatureDto[] | undefined;

    constructor(data?: IFeatureGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FeatureGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFeatureGroupDto {
    name: string | undefined;
    displayName: string | undefined;
    features: FeatureDto[] | undefined;
}

export class FeatureProviderDto implements IFeatureProviderDto {
    name!: string | undefined;
    key!: string | undefined;

    constructor(data?: IFeatureProviderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.key = _data["key"];
        }
    }

    static fromJS(data: any): FeatureProviderDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureProviderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["key"] = this.key;
        return data;
    }
}

export interface IFeatureProviderDto {
    name: string | undefined;
    key: string | undefined;
}

export class FileAggregateRoute implements IFileAggregateRoute {
    routeKeys!: string[] | undefined;
    routeKeysConfig!: AggregateRouteConfig[] | undefined;
    upstreamPathTemplate!: string | undefined;
    upstreamHost!: string | undefined;
    routeIsCaseSensitive!: boolean;
    aggregator!: string | undefined;
    readonly upstreamHttpMethod!: string[] | undefined;
    priority!: number;

    constructor(data?: IFileAggregateRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["routeKeys"])) {
                this.routeKeys = [] as any;
                for (let item of _data["routeKeys"])
                    this.routeKeys!.push(item);
            }
            if (Array.isArray(_data["routeKeysConfig"])) {
                this.routeKeysConfig = [] as any;
                for (let item of _data["routeKeysConfig"])
                    this.routeKeysConfig!.push(AggregateRouteConfig.fromJS(item));
            }
            this.upstreamPathTemplate = _data["upstreamPathTemplate"];
            this.upstreamHost = _data["upstreamHost"];
            this.routeIsCaseSensitive = _data["routeIsCaseSensitive"];
            this.aggregator = _data["aggregator"];
            if (Array.isArray(_data["upstreamHttpMethod"])) {
                (<any>this).upstreamHttpMethod = [] as any;
                for (let item of _data["upstreamHttpMethod"])
                    (<any>this).upstreamHttpMethod!.push(item);
            }
            this.priority = _data["priority"];
        }
    }

    static fromJS(data: any): FileAggregateRoute {
        data = typeof data === 'object' ? data : {};
        let result = new FileAggregateRoute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.routeKeys)) {
            data["routeKeys"] = [];
            for (let item of this.routeKeys)
                data["routeKeys"].push(item);
        }
        if (Array.isArray(this.routeKeysConfig)) {
            data["routeKeysConfig"] = [];
            for (let item of this.routeKeysConfig)
                data["routeKeysConfig"].push(item.toJSON());
        }
        data["upstreamPathTemplate"] = this.upstreamPathTemplate;
        data["upstreamHost"] = this.upstreamHost;
        data["routeIsCaseSensitive"] = this.routeIsCaseSensitive;
        data["aggregator"] = this.aggregator;
        if (Array.isArray(this.upstreamHttpMethod)) {
            data["upstreamHttpMethod"] = [];
            for (let item of this.upstreamHttpMethod)
                data["upstreamHttpMethod"].push(item);
        }
        data["priority"] = this.priority;
        return data;
    }
}

export interface IFileAggregateRoute {
    routeKeys: string[] | undefined;
    routeKeysConfig: AggregateRouteConfig[] | undefined;
    upstreamPathTemplate: string | undefined;
    upstreamHost: string | undefined;
    routeIsCaseSensitive: boolean;
    aggregator: string | undefined;
    upstreamHttpMethod: string[] | undefined;
    priority: number;
}

export class FileAuthenticationOptions implements IFileAuthenticationOptions {
    authenticationProviderKey!: string | undefined;
    allowedScopes!: string[] | undefined;

    constructor(data?: IFileAuthenticationOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authenticationProviderKey = _data["authenticationProviderKey"];
            if (Array.isArray(_data["allowedScopes"])) {
                this.allowedScopes = [] as any;
                for (let item of _data["allowedScopes"])
                    this.allowedScopes!.push(item);
            }
        }
    }

    static fromJS(data: any): FileAuthenticationOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileAuthenticationOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticationProviderKey"] = this.authenticationProviderKey;
        if (Array.isArray(this.allowedScopes)) {
            data["allowedScopes"] = [];
            for (let item of this.allowedScopes)
                data["allowedScopes"].push(item);
        }
        return data;
    }
}

export interface IFileAuthenticationOptions {
    authenticationProviderKey: string | undefined;
    allowedScopes: string[] | undefined;
}

export class FileCacheOptions implements IFileCacheOptions {
    ttlSeconds!: number;
    region!: string | undefined;

    constructor(data?: IFileCacheOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ttlSeconds = _data["ttlSeconds"];
            this.region = _data["region"];
        }
    }

    static fromJS(data: any): FileCacheOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileCacheOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ttlSeconds"] = this.ttlSeconds;
        data["region"] = this.region;
        return data;
    }
}

export interface IFileCacheOptions {
    ttlSeconds: number;
    region: string | undefined;
}

export class FileConfiguration implements IFileConfiguration {
    routes!: FileRoute[] | undefined;
    dynamicRoutes!: FileDynamicRoute[] | undefined;
    aggregates!: FileAggregateRoute[] | undefined;
    globalConfiguration!: FileGlobalConfiguration;

    constructor(data?: IFileConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["routes"])) {
                this.routes = [] as any;
                for (let item of _data["routes"])
                    this.routes!.push(FileRoute.fromJS(item));
            }
            if (Array.isArray(_data["dynamicRoutes"])) {
                this.dynamicRoutes = [] as any;
                for (let item of _data["dynamicRoutes"])
                    this.dynamicRoutes!.push(FileDynamicRoute.fromJS(item));
            }
            if (Array.isArray(_data["aggregates"])) {
                this.aggregates = [] as any;
                for (let item of _data["aggregates"])
                    this.aggregates!.push(FileAggregateRoute.fromJS(item));
            }
            this.globalConfiguration = _data["globalConfiguration"] ? FileGlobalConfiguration.fromJS(_data["globalConfiguration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FileConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new FileConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.routes)) {
            data["routes"] = [];
            for (let item of this.routes)
                data["routes"].push(item.toJSON());
        }
        if (Array.isArray(this.dynamicRoutes)) {
            data["dynamicRoutes"] = [];
            for (let item of this.dynamicRoutes)
                data["dynamicRoutes"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregates)) {
            data["aggregates"] = [];
            for (let item of this.aggregates)
                data["aggregates"].push(item.toJSON());
        }
        data["globalConfiguration"] = this.globalConfiguration ? this.globalConfiguration.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFileConfiguration {
    routes: FileRoute[] | undefined;
    dynamicRoutes: FileDynamicRoute[] | undefined;
    aggregates: FileAggregateRoute[] | undefined;
    globalConfiguration: FileGlobalConfiguration;
}

export class FileDynamicRoute implements IFileDynamicRoute {
    serviceName!: string | undefined;
    rateLimitRule!: FileRateLimitRule;
    downstreamHttpVersion!: string | undefined;

    constructor(data?: IFileDynamicRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serviceName = _data["serviceName"];
            this.rateLimitRule = _data["rateLimitRule"] ? FileRateLimitRule.fromJS(_data["rateLimitRule"]) : <any>undefined;
            this.downstreamHttpVersion = _data["downstreamHttpVersion"];
        }
    }

    static fromJS(data: any): FileDynamicRoute {
        data = typeof data === 'object' ? data : {};
        let result = new FileDynamicRoute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceName"] = this.serviceName;
        data["rateLimitRule"] = this.rateLimitRule ? this.rateLimitRule.toJSON() : <any>undefined;
        data["downstreamHttpVersion"] = this.downstreamHttpVersion;
        return data;
    }
}

export interface IFileDynamicRoute {
    serviceName: string | undefined;
    rateLimitRule: FileRateLimitRule;
    downstreamHttpVersion: string | undefined;
}

export class FileGlobalConfiguration implements IFileGlobalConfiguration {
    requestIdKey!: string | undefined;
    serviceDiscoveryProvider!: FileServiceDiscoveryProvider;
    rateLimitOptions!: FileRateLimitOptions;
    qoSOptions!: FileQoSOptions;
    baseUrl!: string | undefined;
    loadBalancerOptions!: FileLoadBalancerOptions;
    downstreamScheme!: string | undefined;
    httpHandlerOptions!: FileHttpHandlerOptions;
    downstreamHttpVersion!: string | undefined;

    constructor(data?: IFileGlobalConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestIdKey = _data["requestIdKey"];
            this.serviceDiscoveryProvider = _data["serviceDiscoveryProvider"] ? FileServiceDiscoveryProvider.fromJS(_data["serviceDiscoveryProvider"]) : <any>undefined;
            this.rateLimitOptions = _data["rateLimitOptions"] ? FileRateLimitOptions.fromJS(_data["rateLimitOptions"]) : <any>undefined;
            this.qoSOptions = _data["qoSOptions"] ? FileQoSOptions.fromJS(_data["qoSOptions"]) : <any>undefined;
            this.baseUrl = _data["baseUrl"];
            this.loadBalancerOptions = _data["loadBalancerOptions"] ? FileLoadBalancerOptions.fromJS(_data["loadBalancerOptions"]) : <any>undefined;
            this.downstreamScheme = _data["downstreamScheme"];
            this.httpHandlerOptions = _data["httpHandlerOptions"] ? FileHttpHandlerOptions.fromJS(_data["httpHandlerOptions"]) : <any>undefined;
            this.downstreamHttpVersion = _data["downstreamHttpVersion"];
        }
    }

    static fromJS(data: any): FileGlobalConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new FileGlobalConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestIdKey"] = this.requestIdKey;
        data["serviceDiscoveryProvider"] = this.serviceDiscoveryProvider ? this.serviceDiscoveryProvider.toJSON() : <any>undefined;
        data["rateLimitOptions"] = this.rateLimitOptions ? this.rateLimitOptions.toJSON() : <any>undefined;
        data["qoSOptions"] = this.qoSOptions ? this.qoSOptions.toJSON() : <any>undefined;
        data["baseUrl"] = this.baseUrl;
        data["loadBalancerOptions"] = this.loadBalancerOptions ? this.loadBalancerOptions.toJSON() : <any>undefined;
        data["downstreamScheme"] = this.downstreamScheme;
        data["httpHandlerOptions"] = this.httpHandlerOptions ? this.httpHandlerOptions.toJSON() : <any>undefined;
        data["downstreamHttpVersion"] = this.downstreamHttpVersion;
        return data;
    }
}

export interface IFileGlobalConfiguration {
    requestIdKey: string | undefined;
    serviceDiscoveryProvider: FileServiceDiscoveryProvider;
    rateLimitOptions: FileRateLimitOptions;
    qoSOptions: FileQoSOptions;
    baseUrl: string | undefined;
    loadBalancerOptions: FileLoadBalancerOptions;
    downstreamScheme: string | undefined;
    httpHandlerOptions: FileHttpHandlerOptions;
    downstreamHttpVersion: string | undefined;
}

export class FileHostAndPort implements IFileHostAndPort {
    host!: string | undefined;
    port!: number;

    constructor(data?: IFileHostAndPort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.host = _data["host"];
            this.port = _data["port"];
        }
    }

    static fromJS(data: any): FileHostAndPort {
        data = typeof data === 'object' ? data : {};
        let result = new FileHostAndPort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["host"] = this.host;
        data["port"] = this.port;
        return data;
    }
}

export interface IFileHostAndPort {
    host: string | undefined;
    port: number;
}

export class FileHttpHandlerOptions implements IFileHttpHandlerOptions {
    allowAutoRedirect!: boolean;
    useCookieContainer!: boolean;
    useTracing!: boolean;
    useProxy!: boolean;
    maxConnectionsPerServer!: number;

    constructor(data?: IFileHttpHandlerOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowAutoRedirect = _data["allowAutoRedirect"];
            this.useCookieContainer = _data["useCookieContainer"];
            this.useTracing = _data["useTracing"];
            this.useProxy = _data["useProxy"];
            this.maxConnectionsPerServer = _data["maxConnectionsPerServer"];
        }
    }

    static fromJS(data: any): FileHttpHandlerOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileHttpHandlerOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowAutoRedirect"] = this.allowAutoRedirect;
        data["useCookieContainer"] = this.useCookieContainer;
        data["useTracing"] = this.useTracing;
        data["useProxy"] = this.useProxy;
        data["maxConnectionsPerServer"] = this.maxConnectionsPerServer;
        return data;
    }
}

export interface IFileHttpHandlerOptions {
    allowAutoRedirect: boolean;
    useCookieContainer: boolean;
    useTracing: boolean;
    useProxy: boolean;
    maxConnectionsPerServer: number;
}

export class FileLoadBalancerOptions implements IFileLoadBalancerOptions {
    type!: string | undefined;
    key!: string | undefined;
    expiry!: number;

    constructor(data?: IFileLoadBalancerOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.key = _data["key"];
            this.expiry = _data["expiry"];
        }
    }

    static fromJS(data: any): FileLoadBalancerOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileLoadBalancerOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["key"] = this.key;
        data["expiry"] = this.expiry;
        return data;
    }
}

export interface IFileLoadBalancerOptions {
    type: string | undefined;
    key: string | undefined;
    expiry: number;
}

export class FileQoSOptions implements IFileQoSOptions {
    exceptionsAllowedBeforeBreaking!: number;
    durationOfBreak!: number;
    timeoutValue!: number;

    constructor(data?: IFileQoSOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exceptionsAllowedBeforeBreaking = _data["exceptionsAllowedBeforeBreaking"];
            this.durationOfBreak = _data["durationOfBreak"];
            this.timeoutValue = _data["timeoutValue"];
        }
    }

    static fromJS(data: any): FileQoSOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileQoSOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exceptionsAllowedBeforeBreaking"] = this.exceptionsAllowedBeforeBreaking;
        data["durationOfBreak"] = this.durationOfBreak;
        data["timeoutValue"] = this.timeoutValue;
        return data;
    }
}

export interface IFileQoSOptions {
    exceptionsAllowedBeforeBreaking: number;
    durationOfBreak: number;
    timeoutValue: number;
}

export class FileRateLimitOptions implements IFileRateLimitOptions {
    clientIdHeader!: string | undefined;
    quotaExceededMessage!: string | undefined;
    rateLimitCounterPrefix!: string | undefined;
    disableRateLimitHeaders!: boolean;
    httpStatusCode!: number;

    constructor(data?: IFileRateLimitOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientIdHeader = _data["clientIdHeader"];
            this.quotaExceededMessage = _data["quotaExceededMessage"];
            this.rateLimitCounterPrefix = _data["rateLimitCounterPrefix"];
            this.disableRateLimitHeaders = _data["disableRateLimitHeaders"];
            this.httpStatusCode = _data["httpStatusCode"];
        }
    }

    static fromJS(data: any): FileRateLimitOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileRateLimitOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientIdHeader"] = this.clientIdHeader;
        data["quotaExceededMessage"] = this.quotaExceededMessage;
        data["rateLimitCounterPrefix"] = this.rateLimitCounterPrefix;
        data["disableRateLimitHeaders"] = this.disableRateLimitHeaders;
        data["httpStatusCode"] = this.httpStatusCode;
        return data;
    }
}

export interface IFileRateLimitOptions {
    clientIdHeader: string | undefined;
    quotaExceededMessage: string | undefined;
    rateLimitCounterPrefix: string | undefined;
    disableRateLimitHeaders: boolean;
    httpStatusCode: number;
}

export class FileRateLimitRule implements IFileRateLimitRule {
    clientWhitelist!: string[] | undefined;
    enableRateLimiting!: boolean;
    period!: string | undefined;
    periodTimespan!: number;
    limit!: number;

    constructor(data?: IFileRateLimitRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["clientWhitelist"])) {
                this.clientWhitelist = [] as any;
                for (let item of _data["clientWhitelist"])
                    this.clientWhitelist!.push(item);
            }
            this.enableRateLimiting = _data["enableRateLimiting"];
            this.period = _data["period"];
            this.periodTimespan = _data["periodTimespan"];
            this.limit = _data["limit"];
        }
    }

    static fromJS(data: any): FileRateLimitRule {
        data = typeof data === 'object' ? data : {};
        let result = new FileRateLimitRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.clientWhitelist)) {
            data["clientWhitelist"] = [];
            for (let item of this.clientWhitelist)
                data["clientWhitelist"].push(item);
        }
        data["enableRateLimiting"] = this.enableRateLimiting;
        data["period"] = this.period;
        data["periodTimespan"] = this.periodTimespan;
        data["limit"] = this.limit;
        return data;
    }
}

export interface IFileRateLimitRule {
    clientWhitelist: string[] | undefined;
    enableRateLimiting: boolean;
    period: string | undefined;
    periodTimespan: number;
    limit: number;
}

export class FileRoute implements IFileRoute {
    downstreamPathTemplate!: string | undefined;
    upstreamPathTemplate!: string | undefined;
    upstreamHttpMethod!: string[] | undefined;
    downstreamHttpMethod!: string | undefined;
    addHeadersToRequest!: { [key: string]: string; } | undefined;
    upstreamHeaderTransform!: { [key: string]: string; } | undefined;
    downstreamHeaderTransform!: { [key: string]: string; } | undefined;
    addClaimsToRequest!: { [key: string]: string; } | undefined;
    routeClaimsRequirement!: { [key: string]: string; } | undefined;
    addQueriesToRequest!: { [key: string]: string; } | undefined;
    changeDownstreamPathTemplate!: { [key: string]: string; } | undefined;
    requestIdKey!: string | undefined;
    fileCacheOptions!: FileCacheOptions;
    routeIsCaseSensitive!: boolean;
    serviceName!: string | undefined;
    serviceNamespace!: string | undefined;
    downstreamScheme!: string | undefined;
    qoSOptions!: FileQoSOptions;
    loadBalancerOptions!: FileLoadBalancerOptions;
    rateLimitOptions!: FileRateLimitRule;
    authenticationOptions!: FileAuthenticationOptions;
    httpHandlerOptions!: FileHttpHandlerOptions;
    downstreamHostAndPorts!: FileHostAndPort[] | undefined;
    upstreamHost!: string | undefined;
    key!: string | undefined;
    delegatingHandlers!: string[] | undefined;
    priority!: number;
    timeout!: number;
    dangerousAcceptAnyServerCertificateValidator!: boolean;
    securityOptions!: FileSecurityOptions;
    downstreamHttpVersion!: string | undefined;

    constructor(data?: IFileRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.downstreamPathTemplate = _data["downstreamPathTemplate"];
            this.upstreamPathTemplate = _data["upstreamPathTemplate"];
            if (Array.isArray(_data["upstreamHttpMethod"])) {
                this.upstreamHttpMethod = [] as any;
                for (let item of _data["upstreamHttpMethod"])
                    this.upstreamHttpMethod!.push(item);
            }
            this.downstreamHttpMethod = _data["downstreamHttpMethod"];
            if (_data["addHeadersToRequest"]) {
                this.addHeadersToRequest = {} as any;
                for (let key in _data["addHeadersToRequest"]) {
                    if (_data["addHeadersToRequest"].hasOwnProperty(key))
                        (<any>this.addHeadersToRequest)![key] = _data["addHeadersToRequest"][key];
                }
            }
            if (_data["upstreamHeaderTransform"]) {
                this.upstreamHeaderTransform = {} as any;
                for (let key in _data["upstreamHeaderTransform"]) {
                    if (_data["upstreamHeaderTransform"].hasOwnProperty(key))
                        (<any>this.upstreamHeaderTransform)![key] = _data["upstreamHeaderTransform"][key];
                }
            }
            if (_data["downstreamHeaderTransform"]) {
                this.downstreamHeaderTransform = {} as any;
                for (let key in _data["downstreamHeaderTransform"]) {
                    if (_data["downstreamHeaderTransform"].hasOwnProperty(key))
                        (<any>this.downstreamHeaderTransform)![key] = _data["downstreamHeaderTransform"][key];
                }
            }
            if (_data["addClaimsToRequest"]) {
                this.addClaimsToRequest = {} as any;
                for (let key in _data["addClaimsToRequest"]) {
                    if (_data["addClaimsToRequest"].hasOwnProperty(key))
                        (<any>this.addClaimsToRequest)![key] = _data["addClaimsToRequest"][key];
                }
            }
            if (_data["routeClaimsRequirement"]) {
                this.routeClaimsRequirement = {} as any;
                for (let key in _data["routeClaimsRequirement"]) {
                    if (_data["routeClaimsRequirement"].hasOwnProperty(key))
                        (<any>this.routeClaimsRequirement)![key] = _data["routeClaimsRequirement"][key];
                }
            }
            if (_data["addQueriesToRequest"]) {
                this.addQueriesToRequest = {} as any;
                for (let key in _data["addQueriesToRequest"]) {
                    if (_data["addQueriesToRequest"].hasOwnProperty(key))
                        (<any>this.addQueriesToRequest)![key] = _data["addQueriesToRequest"][key];
                }
            }
            if (_data["changeDownstreamPathTemplate"]) {
                this.changeDownstreamPathTemplate = {} as any;
                for (let key in _data["changeDownstreamPathTemplate"]) {
                    if (_data["changeDownstreamPathTemplate"].hasOwnProperty(key))
                        (<any>this.changeDownstreamPathTemplate)![key] = _data["changeDownstreamPathTemplate"][key];
                }
            }
            this.requestIdKey = _data["requestIdKey"];
            this.fileCacheOptions = _data["fileCacheOptions"] ? FileCacheOptions.fromJS(_data["fileCacheOptions"]) : <any>undefined;
            this.routeIsCaseSensitive = _data["routeIsCaseSensitive"];
            this.serviceName = _data["serviceName"];
            this.serviceNamespace = _data["serviceNamespace"];
            this.downstreamScheme = _data["downstreamScheme"];
            this.qoSOptions = _data["qoSOptions"] ? FileQoSOptions.fromJS(_data["qoSOptions"]) : <any>undefined;
            this.loadBalancerOptions = _data["loadBalancerOptions"] ? FileLoadBalancerOptions.fromJS(_data["loadBalancerOptions"]) : <any>undefined;
            this.rateLimitOptions = _data["rateLimitOptions"] ? FileRateLimitRule.fromJS(_data["rateLimitOptions"]) : <any>undefined;
            this.authenticationOptions = _data["authenticationOptions"] ? FileAuthenticationOptions.fromJS(_data["authenticationOptions"]) : <any>undefined;
            this.httpHandlerOptions = _data["httpHandlerOptions"] ? FileHttpHandlerOptions.fromJS(_data["httpHandlerOptions"]) : <any>undefined;
            if (Array.isArray(_data["downstreamHostAndPorts"])) {
                this.downstreamHostAndPorts = [] as any;
                for (let item of _data["downstreamHostAndPorts"])
                    this.downstreamHostAndPorts!.push(FileHostAndPort.fromJS(item));
            }
            this.upstreamHost = _data["upstreamHost"];
            this.key = _data["key"];
            if (Array.isArray(_data["delegatingHandlers"])) {
                this.delegatingHandlers = [] as any;
                for (let item of _data["delegatingHandlers"])
                    this.delegatingHandlers!.push(item);
            }
            this.priority = _data["priority"];
            this.timeout = _data["timeout"];
            this.dangerousAcceptAnyServerCertificateValidator = _data["dangerousAcceptAnyServerCertificateValidator"];
            this.securityOptions = _data["securityOptions"] ? FileSecurityOptions.fromJS(_data["securityOptions"]) : <any>undefined;
            this.downstreamHttpVersion = _data["downstreamHttpVersion"];
        }
    }

    static fromJS(data: any): FileRoute {
        data = typeof data === 'object' ? data : {};
        let result = new FileRoute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["downstreamPathTemplate"] = this.downstreamPathTemplate;
        data["upstreamPathTemplate"] = this.upstreamPathTemplate;
        if (Array.isArray(this.upstreamHttpMethod)) {
            data["upstreamHttpMethod"] = [];
            for (let item of this.upstreamHttpMethod)
                data["upstreamHttpMethod"].push(item);
        }
        data["downstreamHttpMethod"] = this.downstreamHttpMethod;
        if (this.addHeadersToRequest) {
            data["addHeadersToRequest"] = {};
            for (let key in this.addHeadersToRequest) {
                if (this.addHeadersToRequest.hasOwnProperty(key))
                    (<any>data["addHeadersToRequest"])[key] = this.addHeadersToRequest[key];
            }
        }
        if (this.upstreamHeaderTransform) {
            data["upstreamHeaderTransform"] = {};
            for (let key in this.upstreamHeaderTransform) {
                if (this.upstreamHeaderTransform.hasOwnProperty(key))
                    (<any>data["upstreamHeaderTransform"])[key] = this.upstreamHeaderTransform[key];
            }
        }
        if (this.downstreamHeaderTransform) {
            data["downstreamHeaderTransform"] = {};
            for (let key in this.downstreamHeaderTransform) {
                if (this.downstreamHeaderTransform.hasOwnProperty(key))
                    (<any>data["downstreamHeaderTransform"])[key] = this.downstreamHeaderTransform[key];
            }
        }
        if (this.addClaimsToRequest) {
            data["addClaimsToRequest"] = {};
            for (let key in this.addClaimsToRequest) {
                if (this.addClaimsToRequest.hasOwnProperty(key))
                    (<any>data["addClaimsToRequest"])[key] = this.addClaimsToRequest[key];
            }
        }
        if (this.routeClaimsRequirement) {
            data["routeClaimsRequirement"] = {};
            for (let key in this.routeClaimsRequirement) {
                if (this.routeClaimsRequirement.hasOwnProperty(key))
                    (<any>data["routeClaimsRequirement"])[key] = this.routeClaimsRequirement[key];
            }
        }
        if (this.addQueriesToRequest) {
            data["addQueriesToRequest"] = {};
            for (let key in this.addQueriesToRequest) {
                if (this.addQueriesToRequest.hasOwnProperty(key))
                    (<any>data["addQueriesToRequest"])[key] = this.addQueriesToRequest[key];
            }
        }
        if (this.changeDownstreamPathTemplate) {
            data["changeDownstreamPathTemplate"] = {};
            for (let key in this.changeDownstreamPathTemplate) {
                if (this.changeDownstreamPathTemplate.hasOwnProperty(key))
                    (<any>data["changeDownstreamPathTemplate"])[key] = this.changeDownstreamPathTemplate[key];
            }
        }
        data["requestIdKey"] = this.requestIdKey;
        data["fileCacheOptions"] = this.fileCacheOptions ? this.fileCacheOptions.toJSON() : <any>undefined;
        data["routeIsCaseSensitive"] = this.routeIsCaseSensitive;
        data["serviceName"] = this.serviceName;
        data["serviceNamespace"] = this.serviceNamespace;
        data["downstreamScheme"] = this.downstreamScheme;
        data["qoSOptions"] = this.qoSOptions ? this.qoSOptions.toJSON() : <any>undefined;
        data["loadBalancerOptions"] = this.loadBalancerOptions ? this.loadBalancerOptions.toJSON() : <any>undefined;
        data["rateLimitOptions"] = this.rateLimitOptions ? this.rateLimitOptions.toJSON() : <any>undefined;
        data["authenticationOptions"] = this.authenticationOptions ? this.authenticationOptions.toJSON() : <any>undefined;
        data["httpHandlerOptions"] = this.httpHandlerOptions ? this.httpHandlerOptions.toJSON() : <any>undefined;
        if (Array.isArray(this.downstreamHostAndPorts)) {
            data["downstreamHostAndPorts"] = [];
            for (let item of this.downstreamHostAndPorts)
                data["downstreamHostAndPorts"].push(item.toJSON());
        }
        data["upstreamHost"] = this.upstreamHost;
        data["key"] = this.key;
        if (Array.isArray(this.delegatingHandlers)) {
            data["delegatingHandlers"] = [];
            for (let item of this.delegatingHandlers)
                data["delegatingHandlers"].push(item);
        }
        data["priority"] = this.priority;
        data["timeout"] = this.timeout;
        data["dangerousAcceptAnyServerCertificateValidator"] = this.dangerousAcceptAnyServerCertificateValidator;
        data["securityOptions"] = this.securityOptions ? this.securityOptions.toJSON() : <any>undefined;
        data["downstreamHttpVersion"] = this.downstreamHttpVersion;
        return data;
    }
}

export interface IFileRoute {
    downstreamPathTemplate: string | undefined;
    upstreamPathTemplate: string | undefined;
    upstreamHttpMethod: string[] | undefined;
    downstreamHttpMethod: string | undefined;
    addHeadersToRequest: { [key: string]: string; } | undefined;
    upstreamHeaderTransform: { [key: string]: string; } | undefined;
    downstreamHeaderTransform: { [key: string]: string; } | undefined;
    addClaimsToRequest: { [key: string]: string; } | undefined;
    routeClaimsRequirement: { [key: string]: string; } | undefined;
    addQueriesToRequest: { [key: string]: string; } | undefined;
    changeDownstreamPathTemplate: { [key: string]: string; } | undefined;
    requestIdKey: string | undefined;
    fileCacheOptions: FileCacheOptions;
    routeIsCaseSensitive: boolean;
    serviceName: string | undefined;
    serviceNamespace: string | undefined;
    downstreamScheme: string | undefined;
    qoSOptions: FileQoSOptions;
    loadBalancerOptions: FileLoadBalancerOptions;
    rateLimitOptions: FileRateLimitRule;
    authenticationOptions: FileAuthenticationOptions;
    httpHandlerOptions: FileHttpHandlerOptions;
    downstreamHostAndPorts: FileHostAndPort[] | undefined;
    upstreamHost: string | undefined;
    key: string | undefined;
    delegatingHandlers: string[] | undefined;
    priority: number;
    timeout: number;
    dangerousAcceptAnyServerCertificateValidator: boolean;
    securityOptions: FileSecurityOptions;
    downstreamHttpVersion: string | undefined;
}

export class FileSecurityOptions implements IFileSecurityOptions {
    ipAllowedList!: string[] | undefined;
    ipBlockedList!: string[] | undefined;

    constructor(data?: IFileSecurityOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ipAllowedList"])) {
                this.ipAllowedList = [] as any;
                for (let item of _data["ipAllowedList"])
                    this.ipAllowedList!.push(item);
            }
            if (Array.isArray(_data["ipBlockedList"])) {
                this.ipBlockedList = [] as any;
                for (let item of _data["ipBlockedList"])
                    this.ipBlockedList!.push(item);
            }
        }
    }

    static fromJS(data: any): FileSecurityOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileSecurityOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ipAllowedList)) {
            data["ipAllowedList"] = [];
            for (let item of this.ipAllowedList)
                data["ipAllowedList"].push(item);
        }
        if (Array.isArray(this.ipBlockedList)) {
            data["ipBlockedList"] = [];
            for (let item of this.ipBlockedList)
                data["ipBlockedList"].push(item);
        }
        return data;
    }
}

export interface IFileSecurityOptions {
    ipAllowedList: string[] | undefined;
    ipBlockedList: string[] | undefined;
}

export class FileServiceDiscoveryProvider implements IFileServiceDiscoveryProvider {
    scheme!: string | undefined;
    host!: string | undefined;
    port!: number;
    type!: string | undefined;
    token!: string | undefined;
    configurationKey!: string | undefined;
    pollingInterval!: number;
    namespace!: string | undefined;

    constructor(data?: IFileServiceDiscoveryProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scheme = _data["scheme"];
            this.host = _data["host"];
            this.port = _data["port"];
            this.type = _data["type"];
            this.token = _data["token"];
            this.configurationKey = _data["configurationKey"];
            this.pollingInterval = _data["pollingInterval"];
            this.namespace = _data["namespace"];
        }
    }

    static fromJS(data: any): FileServiceDiscoveryProvider {
        data = typeof data === 'object' ? data : {};
        let result = new FileServiceDiscoveryProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheme"] = this.scheme;
        data["host"] = this.host;
        data["port"] = this.port;
        data["type"] = this.type;
        data["token"] = this.token;
        data["configurationKey"] = this.configurationKey;
        data["pollingInterval"] = this.pollingInterval;
        data["namespace"] = this.namespace;
        return data;
    }
}

export interface IFileServiceDiscoveryProvider {
    scheme: string | undefined;
    host: string | undefined;
    port: number;
    type: string | undefined;
    token: string | undefined;
    configurationKey: string | undefined;
    pollingInterval: number;
    namespace: string | undefined;
}

export class FindTenantByNameInput implements IFindTenantByNameInput {
    name!: string | undefined;

    constructor(data?: IFindTenantByNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): FindTenantByNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindTenantByNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IFindTenantByNameInput {
    name: string | undefined;
}

export class FindTenantResultDto implements IFindTenantResultDto {
    success!: boolean;
    tenantId!: string | undefined;
    name!: string | undefined;
    isActive!: boolean;

    constructor(data?: IFindTenantResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): FindTenantResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindTenantResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IFindTenantResultDto {
    success: boolean;
    tenantId: string | undefined;
    name: string | undefined;
    isActive: boolean;
}

export class GetAuditLogPageListOutput implements IGetAuditLogPageListOutput {
    applicationName!: string | undefined;
    userId!: string | undefined;
    userName!: string | undefined;
    tenantId!: string | undefined;
    tenantName!: string | undefined;
    impersonatorUserId!: string | undefined;
    impersonatorTenantId!: string | undefined;
    executionTime!: moment.Moment;
    executionDuration!: number;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    clientId!: string | undefined;
    correlationId!: string | undefined;
    browserInfo!: string | undefined;
    httpMethod!: string | undefined;
    url!: string | undefined;
    exceptions!: string | undefined;
    comments!: string | undefined;
    httpStatusCode!: number | undefined;

    constructor(data?: IGetAuditLogPageListOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationName = _data["applicationName"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.tenantId = _data["tenantId"];
            this.tenantName = _data["tenantName"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.impersonatorTenantId = _data["impersonatorTenantId"];
            this.executionTime = _data["executionTime"] ? moment(_data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = _data["executionDuration"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.clientId = _data["clientId"];
            this.correlationId = _data["correlationId"];
            this.browserInfo = _data["browserInfo"];
            this.httpMethod = _data["httpMethod"];
            this.url = _data["url"];
            this.exceptions = _data["exceptions"];
            this.comments = _data["comments"];
            this.httpStatusCode = _data["httpStatusCode"];
        }
    }

    static fromJS(data: any): GetAuditLogPageListOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAuditLogPageListOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationName"] = this.applicationName;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["tenantName"] = this.tenantName;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["clientId"] = this.clientId;
        data["correlationId"] = this.correlationId;
        data["browserInfo"] = this.browserInfo;
        data["httpMethod"] = this.httpMethod;
        data["url"] = this.url;
        data["exceptions"] = this.exceptions;
        data["comments"] = this.comments;
        data["httpStatusCode"] = this.httpStatusCode;
        return data;
    }
}

export interface IGetAuditLogPageListOutput {
    applicationName: string | undefined;
    userId: string | undefined;
    userName: string | undefined;
    tenantId: string | undefined;
    tenantName: string | undefined;
    impersonatorUserId: string | undefined;
    impersonatorTenantId: string | undefined;
    executionTime: moment.Moment;
    executionDuration: number;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    clientId: string | undefined;
    correlationId: string | undefined;
    browserInfo: string | undefined;
    httpMethod: string | undefined;
    url: string | undefined;
    exceptions: string | undefined;
    comments: string | undefined;
    httpStatusCode: number | undefined;
}

export class GetAuditLogPageListOutputPagedResultDto implements IGetAuditLogPageListOutputPagedResultDto {
    items!: GetAuditLogPageListOutput[] | undefined;
    totalCount!: number;

    constructor(data?: IGetAuditLogPageListOutputPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAuditLogPageListOutput.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetAuditLogPageListOutputPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAuditLogPageListOutputPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IGetAuditLogPageListOutputPagedResultDto {
    items: GetAuditLogPageListOutput[] | undefined;
    totalCount: number;
}

export class GetFeatureListResultDto implements IGetFeatureListResultDto {
    groups!: FeatureGroupDto[] | undefined;

    constructor(data?: IGetFeatureListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(FeatureGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetFeatureListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetFeatureListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetFeatureListResultDto {
    groups: FeatureGroupDto[] | undefined;
}

export class GetPermissionInput implements IGetPermissionInput {
    providerName!: string;
    providerKey!: string;

    constructor(data?: IGetPermissionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.providerName = _data["providerName"];
            this.providerKey = _data["providerKey"];
        }
    }

    static fromJS(data: any): GetPermissionInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPermissionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["providerName"] = this.providerName;
        data["providerKey"] = this.providerKey;
        return data;
    }
}

export interface IGetPermissionInput {
    providerName: string;
    providerKey: string;
}

export class GetPermissionListResultDto implements IGetPermissionListResultDto {
    entityDisplayName!: string | undefined;
    groups!: PermissionGroupDto[] | undefined;

    constructor(data?: IGetPermissionListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityDisplayName = _data["entityDisplayName"];
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(PermissionGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPermissionListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPermissionListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityDisplayName"] = this.entityDisplayName;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetPermissionListResultDto {
    entityDisplayName: string | undefined;
    groups: PermissionGroupDto[] | undefined;
}

export enum HttpStatusCode {
    Continue = 100,
    SwitchingProtocols = 101,
    Processing = 102,
    EarlyHints = 103,
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritativeInformation = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultiStatus = 207,
    AlreadyReported = 208,
    IMUsed = 226,
    MultipleChoices = 300,
    Ambiguous = 301,
    MovedPermanently = 302,
    Moved = 303,
    Found = 304,
    Redirect = 305,
    SeeOther = 306,
    RedirectMethod = 307,
    NotModified = 308,
    UseProxy = 400,
    Unused = 401,
    TemporaryRedirect = 402,
    RedirectKeepVerb = 403,
    PermanentRedirect = 404,
    BadRequest = 405,
    Unauthorized = 406,
    PaymentRequired = 407,
    Forbidden = 408,
    NotFound = 409,
    MethodNotAllowed = 410,
    NotAcceptable = 411,
    ProxyAuthenticationRequired = 412,
    RequestTimeout = 413,
    Conflict = 414,
    Gone = 415,
    LengthRequired = 416,
    PreconditionFailed = 417,
    RequestEntityTooLarge = 421,
    RequestUriTooLong = 422,
    UnsupportedMediaType = 423,
    RequestedRangeNotSatisfiable = 424,
    ExpectationFailed = 426,
    MisdirectedRequest = 428,
    UnprocessableEntity = 429,
    Locked = 431,
    FailedDependency = 451,
    UpgradeRequired = 500,
    PreconditionRequired = 501,
    TooManyRequests = 502,
    RequestHeaderFieldsTooLarge = 503,
    UnavailableForLegalReasons = 504,
    InternalServerError = 505,
    NotImplemented = 506,
    BadGateway = 507,
    ServiceUnavailable = 508,
    GatewayTimeout = 510,
    HttpVersionNotSupported = 511,
}

export class IanaTimeZone implements IIanaTimeZone {
    timeZoneName!: string | undefined;

    constructor(data?: IIanaTimeZone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeZoneName = _data["timeZoneName"];
        }
    }

    static fromJS(data: any): IanaTimeZone {
        data = typeof data === 'object' ? data : {};
        let result = new IanaTimeZone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneName"] = this.timeZoneName;
        return data;
    }
}

export interface IIanaTimeZone {
    timeZoneName: string | undefined;
}

export class IdentityRoleCreateDto implements IIdentityRoleCreateDto {
    readonly extraProperties!: { [key: string]: any; } | undefined;
    name!: string;
    isDefault!: boolean;
    isPublic!: boolean;

    constructor(data?: IIdentityRoleCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            this.isPublic = _data["isPublic"];
        }
    }

    static fromJS(data: any): IdentityRoleCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key];
            }
        }
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["isPublic"] = this.isPublic;
        return data;
    }
}

export interface IIdentityRoleCreateDto {
    extraProperties: { [key: string]: any; } | undefined;
    name: string;
    isDefault: boolean;
    isPublic: boolean;
}

export class IdentityRoleDto implements IIdentityRoleDto {
    readonly extraProperties!: { [key: string]: any; } | undefined;
    id!: string;
    name!: string | undefined;
    isDefault!: boolean;
    isStatic!: boolean;
    isPublic!: boolean;
    concurrencyStamp!: string | undefined;

    constructor(data?: IIdentityRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            this.isStatic = _data["isStatic"];
            this.isPublic = _data["isPublic"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): IdentityRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key];
            }
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["isStatic"] = this.isStatic;
        data["isPublic"] = this.isPublic;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IIdentityRoleDto {
    extraProperties: { [key: string]: any; } | undefined;
    id: string;
    name: string | undefined;
    isDefault: boolean;
    isStatic: boolean;
    isPublic: boolean;
    concurrencyStamp: string | undefined;
}

export class IdentityRoleDtoListResultDto implements IIdentityRoleDtoListResultDto {
    items!: IdentityRoleDto[] | undefined;

    constructor(data?: IIdentityRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdentityRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IdentityRoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIdentityRoleDtoListResultDto {
    items: IdentityRoleDto[] | undefined;
}

export class IdentityRoleDtoPagedResultDto implements IIdentityRoleDtoPagedResultDto {
    items!: IdentityRoleDto[] | undefined;
    totalCount!: number;

    constructor(data?: IIdentityRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdentityRoleDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): IdentityRoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IIdentityRoleDtoPagedResultDto {
    items: IdentityRoleDto[] | undefined;
    totalCount: number;
}

export class IdentityRoleUpdateDto implements IIdentityRoleUpdateDto {
    readonly extraProperties!: { [key: string]: any; } | undefined;
    name!: string;
    isDefault!: boolean;
    isPublic!: boolean;
    concurrencyStamp!: string | undefined;

    constructor(data?: IIdentityRoleUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            this.isPublic = _data["isPublic"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): IdentityRoleUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key];
            }
        }
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["isPublic"] = this.isPublic;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IIdentityRoleUpdateDto {
    extraProperties: { [key: string]: any; } | undefined;
    name: string;
    isDefault: boolean;
    isPublic: boolean;
    concurrencyStamp: string | undefined;
}

export class IdentityUserCreateDto implements IIdentityUserCreateDto {
    readonly extraProperties!: { [key: string]: any; } | undefined;
    userName!: string;
    name!: string | undefined;
    surname!: string | undefined;
    email!: string;
    phoneNumber!: string | undefined;
    isActive!: boolean;
    lockoutEnabled!: boolean;
    roleNames!: string[] | undefined;
    password!: string;

    constructor(data?: IIdentityUserCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.isActive = _data["isActive"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): IdentityUserCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key];
            }
        }
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["isActive"] = this.isActive;
        data["lockoutEnabled"] = this.lockoutEnabled;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data;
    }
}

export interface IIdentityUserCreateDto {
    extraProperties: { [key: string]: any; } | undefined;
    userName: string;
    name: string | undefined;
    surname: string | undefined;
    email: string;
    phoneNumber: string | undefined;
    isActive: boolean;
    lockoutEnabled: boolean;
    roleNames: string[] | undefined;
    password: string;
}

export class IdentityUserDto implements IIdentityUserDto {
    readonly extraProperties!: { [key: string]: any; } | undefined;
    id!: string;
    creationTime!: moment.Moment;
    creatorId!: string | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierId!: string | undefined;
    isDeleted!: boolean;
    deleterId!: string | undefined;
    deletionTime!: moment.Moment | undefined;
    tenantId!: string | undefined;
    userName!: string | undefined;
    name!: string | undefined;
    surname!: string | undefined;
    email!: string | undefined;
    emailConfirmed!: boolean;
    phoneNumber!: string | undefined;
    phoneNumberConfirmed!: boolean;
    isActive!: boolean;
    lockoutEnabled!: boolean;
    lockoutEnd!: moment.Moment | undefined;
    concurrencyStamp!: string | undefined;

    constructor(data?: IIdentityUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterId = _data["deleterId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.email = _data["email"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.isActive = _data["isActive"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? moment(_data["lockoutEnd"].toString()) : <any>undefined;
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): IdentityUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key];
            }
        }
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["isDeleted"] = this.isDeleted;
        data["deleterId"] = this.deleterId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["isActive"] = this.isActive;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IIdentityUserDto {
    extraProperties: { [key: string]: any; } | undefined;
    id: string;
    creationTime: moment.Moment;
    creatorId: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierId: string | undefined;
    isDeleted: boolean;
    deleterId: string | undefined;
    deletionTime: moment.Moment | undefined;
    tenantId: string | undefined;
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    email: string | undefined;
    emailConfirmed: boolean;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
    isActive: boolean;
    lockoutEnabled: boolean;
    lockoutEnd: moment.Moment | undefined;
    concurrencyStamp: string | undefined;
}

export class IdentityUserDtoPagedResultDto implements IIdentityUserDtoPagedResultDto {
    items!: IdentityUserDto[] | undefined;
    totalCount!: number;

    constructor(data?: IIdentityUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdentityUserDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): IdentityUserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IIdentityUserDtoPagedResultDto {
    items: IdentityUserDto[] | undefined;
    totalCount: number;
}

export class IdentityUserUpdateDto implements IIdentityUserUpdateDto {
    readonly extraProperties!: { [key: string]: any; } | undefined;
    userName!: string;
    name!: string | undefined;
    surname!: string | undefined;
    email!: string;
    phoneNumber!: string | undefined;
    isActive!: boolean;
    lockoutEnabled!: boolean;
    roleNames!: string[] | undefined;
    password!: string | undefined;
    concurrencyStamp!: string | undefined;

    constructor(data?: IIdentityUserUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.isActive = _data["isActive"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            this.password = _data["password"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): IdentityUserUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key];
            }
        }
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["isActive"] = this.isActive;
        data["lockoutEnabled"] = this.lockoutEnabled;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IIdentityUserUpdateDto {
    extraProperties: { [key: string]: any; } | undefined;
    userName: string;
    name: string | undefined;
    surname: string | undefined;
    email: string;
    phoneNumber: string | undefined;
    isActive: boolean;
    lockoutEnabled: boolean;
    roleNames: string[] | undefined;
    password: string | undefined;
    concurrencyStamp: string | undefined;
}

export class IdentityUserUpdateRolesDto implements IIdentityUserUpdateRolesDto {
    roleNames!: string[];

    constructor(data?: IIdentityUserUpdateRolesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roleNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
        }
    }

    static fromJS(data: any): IdentityUserUpdateRolesDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserUpdateRolesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        return data;
    }
}

export interface IIdentityUserUpdateRolesDto {
    roleNames: string[];
}

export class IdInput implements IIdInput {
    id!: string;

    constructor(data?: IIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IdInput {
        data = typeof data === 'object' ? data : {};
        let result = new IdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IIdInput {
    id: string;
}

export class IStringValueType implements IIStringValueType {
    readonly name!: string | undefined;
    readonly properties!: { [key: string]: any; } | undefined;
    validator!: IValueValidator;

    constructor(data?: IIStringValueType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key];
                }
            }
            this.validator = _data["validator"] ? IValueValidator.fromJS(_data["validator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IStringValueType {
        data = typeof data === 'object' ? data : {};
        let result = new IStringValueType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIStringValueType {
    name: string | undefined;
    properties: { [key: string]: any; } | undefined;
    validator: IValueValidator;
}

export class IValueValidator implements IIValueValidator {
    readonly name!: string | undefined;
    readonly properties!: { [key: string]: any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key];
            }
        }
        return data;
    }
}

export interface IIValueValidator {
    name: string | undefined;
    properties: { [key: string]: any; } | undefined;
}

export class LanguageInfo implements ILanguageInfo {
    cultureName!: string | undefined;
    uiCultureName!: string | undefined;
    displayName!: string | undefined;
    flagIcon!: string | undefined;

    constructor(data?: ILanguageInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cultureName = _data["cultureName"];
            this.uiCultureName = _data["uiCultureName"];
            this.displayName = _data["displayName"];
            this.flagIcon = _data["flagIcon"];
        }
    }

    static fromJS(data: any): LanguageInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cultureName"] = this.cultureName;
        data["uiCultureName"] = this.uiCultureName;
        data["displayName"] = this.displayName;
        data["flagIcon"] = this.flagIcon;
        return data;
    }
}

export interface ILanguageInfo {
    cultureName: string | undefined;
    uiCultureName: string | undefined;
    displayName: string | undefined;
    flagIcon: string | undefined;
}

export class LocalizableStringDto implements ILocalizableStringDto {
    name!: string | undefined;
    resource!: string | undefined;

    constructor(data?: ILocalizableStringDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.resource = _data["resource"];
        }
    }

    static fromJS(data: any): LocalizableStringDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableStringDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["resource"] = this.resource;
        return data;
    }
}

export interface ILocalizableStringDto {
    name: string | undefined;
    resource: string | undefined;
}

export class LockUserInput implements ILockUserInput {
    userId!: string;
    locked!: boolean;

    constructor(data?: ILockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.locked = _data["locked"];
        }
    }

    static fromJS(data: any): LockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["locked"] = this.locked;
        return data;
    }
}

export interface ILockUserInput {
    userId: string;
    locked: boolean;
}

/** 登录 */
export class LoginInput implements ILoginInput {
    /** 用户名或者邮箱 */
    name!: string | undefined;
    /** 密码 */
    password!: string | undefined;

    constructor(data?: ILoginInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginInput {
        data = typeof data === 'object' ? data : {};
        let result = new LoginInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["password"] = this.password;
        return data;
    }
}

/** 登录 */
export interface ILoginInput {
    /** 用户名或者邮箱 */
    name: string | undefined;
    /** 密码 */
    password: string | undefined;
}

export class LoginOutput implements ILoginOutput {
    id!: string;
    name!: string | undefined;
    userName!: string | undefined;
    token!: string | undefined;
    roles!: string[] | undefined;

    constructor(data?: ILoginOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.userName = _data["userName"];
            this.token = _data["token"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): LoginOutput {
        data = typeof data === 'object' ? data : {};
        let result = new LoginOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["token"] = this.token;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface ILoginOutput {
    id: string;
    name: string | undefined;
    userName: string | undefined;
    token: string | undefined;
    roles: string[] | undefined;
}

export enum LoginResultType {
    Success = 1,
    InvalidUserNameOrPassword = 2,
    NotAllowed = 3,
    LockedOut = 4,
    RequiresTwoFactor = 5,
}

export class MethodParameterApiDescriptionModel implements IMethodParameterApiDescriptionModel {
    name!: string | undefined;
    typeAsString!: string | undefined;
    type!: string | undefined;
    typeSimple!: string | undefined;
    isOptional!: boolean;
    defaultValue!: any | undefined;

    constructor(data?: IMethodParameterApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.typeAsString = _data["typeAsString"];
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
            this.isOptional = _data["isOptional"];
            this.defaultValue = _data["defaultValue"];
        }
    }

    static fromJS(data: any): MethodParameterApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new MethodParameterApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["typeAsString"] = this.typeAsString;
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        data["isOptional"] = this.isOptional;
        data["defaultValue"] = this.defaultValue;
        return data;
    }
}

export interface IMethodParameterApiDescriptionModel {
    name: string | undefined;
    typeAsString: string | undefined;
    type: string | undefined;
    typeSimple: string | undefined;
    isOptional: boolean;
    defaultValue: any | undefined;
}

export class ModuleApiDescriptionModel implements IModuleApiDescriptionModel {
    rootPath!: string | undefined;
    remoteServiceName!: string | undefined;
    controllers!: { [key: string]: ControllerApiDescriptionModel; } | undefined;

    constructor(data?: IModuleApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rootPath = _data["rootPath"];
            this.remoteServiceName = _data["remoteServiceName"];
            if (_data["controllers"]) {
                this.controllers = {} as any;
                for (let key in _data["controllers"]) {
                    if (_data["controllers"].hasOwnProperty(key))
                        (<any>this.controllers)![key] = _data["controllers"][key] ? ControllerApiDescriptionModel.fromJS(_data["controllers"][key]) : new ControllerApiDescriptionModel();
                }
            }
        }
    }

    static fromJS(data: any): ModuleApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rootPath"] = this.rootPath;
        data["remoteServiceName"] = this.remoteServiceName;
        if (this.controllers) {
            data["controllers"] = {};
            for (let key in this.controllers) {
                if (this.controllers.hasOwnProperty(key))
                    (<any>data["controllers"])[key] = this.controllers[key] ? this.controllers[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IModuleApiDescriptionModel {
    rootPath: string | undefined;
    remoteServiceName: string | undefined;
    controllers: { [key: string]: ControllerApiDescriptionModel; } | undefined;
}

export class ModuleExtensionDto implements IModuleExtensionDto {
    entities!: { [key: string]: EntityExtensionDto; } | undefined;
    configuration!: { [key: string]: any; } | undefined;

    constructor(data?: IModuleExtensionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["entities"]) {
                this.entities = {} as any;
                for (let key in _data["entities"]) {
                    if (_data["entities"].hasOwnProperty(key))
                        (<any>this.entities)![key] = _data["entities"][key] ? EntityExtensionDto.fromJS(_data["entities"][key]) : new EntityExtensionDto();
                }
            }
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
        }
    }

    static fromJS(data: any): ModuleExtensionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleExtensionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.entities) {
            data["entities"] = {};
            for (let key in this.entities) {
                if (this.entities.hasOwnProperty(key))
                    (<any>data["entities"])[key] = this.entities[key] ? this.entities[key].toJSON() : <any>undefined;
            }
        }
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = this.configuration[key];
            }
        }
        return data;
    }
}

export interface IModuleExtensionDto {
    entities: { [key: string]: EntityExtensionDto; } | undefined;
    configuration: { [key: string]: any; } | undefined;
}

export class MultiTenancyInfoDto implements IMultiTenancyInfoDto {
    isEnabled!: boolean;

    constructor(data?: IMultiTenancyInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): MultiTenancyInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new MultiTenancyInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IMultiTenancyInfoDto {
    isEnabled: boolean;
}

export class NameValue implements INameValue {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValue {
    name: string | undefined;
    value: string | undefined;
}

export class ObjectExtensionsDto implements IObjectExtensionsDto {
    modules!: { [key: string]: ModuleExtensionDto; } | undefined;
    enums!: { [key: string]: ExtensionEnumDto; } | undefined;

    constructor(data?: IObjectExtensionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["modules"]) {
                this.modules = {} as any;
                for (let key in _data["modules"]) {
                    if (_data["modules"].hasOwnProperty(key))
                        (<any>this.modules)![key] = _data["modules"][key] ? ModuleExtensionDto.fromJS(_data["modules"][key]) : new ModuleExtensionDto();
                }
            }
            if (_data["enums"]) {
                this.enums = {} as any;
                for (let key in _data["enums"]) {
                    if (_data["enums"].hasOwnProperty(key))
                        (<any>this.enums)![key] = _data["enums"][key] ? ExtensionEnumDto.fromJS(_data["enums"][key]) : new ExtensionEnumDto();
                }
            }
        }
    }

    static fromJS(data: any): ObjectExtensionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectExtensionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.modules) {
            data["modules"] = {};
            for (let key in this.modules) {
                if (this.modules.hasOwnProperty(key))
                    (<any>data["modules"])[key] = this.modules[key] ? this.modules[key].toJSON() : <any>undefined;
            }
        }
        if (this.enums) {
            data["enums"] = {};
            for (let key in this.enums) {
                if (this.enums.hasOwnProperty(key))
                    (<any>data["enums"])[key] = this.enums[key] ? this.enums[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IObjectExtensionsDto {
    modules: { [key: string]: ModuleExtensionDto; } | undefined;
    enums: { [key: string]: ExtensionEnumDto; } | undefined;
}

export class PagingAuditLogListInput implements IPagingAuditLogListInput {
    /** 当前页面.默认从1开始 */
    pageIndex!: number;
    /** 每页多少条.每页显示多少记录 */
    pageSize!: number;
    /** 跳过多少条 */
    readonly skipCount!: number;
    sorting!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    httpMethod!: string | undefined;
    url!: string | undefined;
    userName!: string | undefined;
    applicationName!: string | undefined;
    correlationId!: string | undefined;
    maxExecutionDuration!: number | undefined;
    minExecutionDuration!: number | undefined;
    hasException!: boolean | undefined;
    httpStatusCode!: HttpStatusCode;

    constructor(data?: IPagingAuditLogListInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.httpMethod = _data["httpMethod"];
            this.url = _data["url"];
            this.userName = _data["userName"];
            this.applicationName = _data["applicationName"];
            this.correlationId = _data["correlationId"];
            this.maxExecutionDuration = _data["maxExecutionDuration"];
            this.minExecutionDuration = _data["minExecutionDuration"];
            this.hasException = _data["hasException"];
            this.httpStatusCode = _data["httpStatusCode"];
        }
    }

    static fromJS(data: any): PagingAuditLogListInput {
        data = typeof data === 'object' ? data : {};
        let result = new PagingAuditLogListInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["httpMethod"] = this.httpMethod;
        data["url"] = this.url;
        data["userName"] = this.userName;
        data["applicationName"] = this.applicationName;
        data["correlationId"] = this.correlationId;
        data["maxExecutionDuration"] = this.maxExecutionDuration;
        data["minExecutionDuration"] = this.minExecutionDuration;
        data["hasException"] = this.hasException;
        data["httpStatusCode"] = this.httpStatusCode;
        return data;
    }
}

export interface IPagingAuditLogListInput {
    /** 当前页面.默认从1开始 */
    pageIndex: number;
    /** 每页多少条.每页显示多少记录 */
    pageSize: number;
    /** 跳过多少条 */
    skipCount: number;
    sorting: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    httpMethod: string | undefined;
    url: string | undefined;
    userName: string | undefined;
    applicationName: string | undefined;
    correlationId: string | undefined;
    maxExecutionDuration: number | undefined;
    minExecutionDuration: number | undefined;
    hasException: boolean | undefined;
    httpStatusCode: HttpStatusCode;
}

export class PagingRoleListInput implements IPagingRoleListInput {
    /** 当前页面.默认从1开始 */
    pageIndex!: number;
    /** 每页多少条.每页显示多少记录 */
    pageSize!: number;
    /** 跳过多少条 */
    readonly skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IPagingRoleListInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): PagingRoleListInput {
        data = typeof data === 'object' ? data : {};
        let result = new PagingRoleListInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IPagingRoleListInput {
    /** 当前页面.默认从1开始 */
    pageIndex: number;
    /** 每页多少条.每页显示多少记录 */
    pageSize: number;
    /** 跳过多少条 */
    skipCount: number;
    filter: string | undefined;
}

export class PagingTenantInput implements IPagingTenantInput {
    /** 当前页面.默认从1开始 */
    pageIndex!: number;
    /** 每页多少条.每页显示多少记录 */
    pageSize!: number;
    /** 跳过多少条 */
    readonly skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IPagingTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): PagingTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new PagingTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IPagingTenantInput {
    /** 当前页面.默认从1开始 */
    pageIndex: number;
    /** 每页多少条.每页显示多少记录 */
    pageSize: number;
    /** 跳过多少条 */
    skipCount: number;
    filter: string | undefined;
}

export class PagingUserListInput implements IPagingUserListInput {
    /** 当前页面.默认从1开始 */
    pageIndex!: number;
    /** 每页多少条.每页显示多少记录 */
    pageSize!: number;
    /** 跳过多少条 */
    readonly skipCount!: number;
    /** 关键字 */
    filter!: string | undefined;

    constructor(data?: IPagingUserListInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): PagingUserListInput {
        data = typeof data === 'object' ? data : {};
        let result = new PagingUserListInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IPagingUserListInput {
    /** 当前页面.默认从1开始 */
    pageIndex: number;
    /** 每页多少条.每页显示多少记录 */
    pageSize: number;
    /** 跳过多少条 */
    skipCount: number;
    /** 关键字 */
    filter: string | undefined;
}

export class ParameterApiDescriptionModel implements IParameterApiDescriptionModel {
    nameOnMethod!: string | undefined;
    name!: string | undefined;
    jsonName!: string | undefined;
    type!: string | undefined;
    typeSimple!: string | undefined;
    isOptional!: boolean;
    defaultValue!: any | undefined;
    constraintTypes!: string[] | undefined;
    bindingSourceId!: string | undefined;
    descriptorName!: string | undefined;

    constructor(data?: IParameterApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nameOnMethod = _data["nameOnMethod"];
            this.name = _data["name"];
            this.jsonName = _data["jsonName"];
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
            this.isOptional = _data["isOptional"];
            this.defaultValue = _data["defaultValue"];
            if (Array.isArray(_data["constraintTypes"])) {
                this.constraintTypes = [] as any;
                for (let item of _data["constraintTypes"])
                    this.constraintTypes!.push(item);
            }
            this.bindingSourceId = _data["bindingSourceId"];
            this.descriptorName = _data["descriptorName"];
        }
    }

    static fromJS(data: any): ParameterApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameOnMethod"] = this.nameOnMethod;
        data["name"] = this.name;
        data["jsonName"] = this.jsonName;
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        data["isOptional"] = this.isOptional;
        data["defaultValue"] = this.defaultValue;
        if (Array.isArray(this.constraintTypes)) {
            data["constraintTypes"] = [];
            for (let item of this.constraintTypes)
                data["constraintTypes"].push(item);
        }
        data["bindingSourceId"] = this.bindingSourceId;
        data["descriptorName"] = this.descriptorName;
        return data;
    }
}

export interface IParameterApiDescriptionModel {
    nameOnMethod: string | undefined;
    name: string | undefined;
    jsonName: string | undefined;
    type: string | undefined;
    typeSimple: string | undefined;
    isOptional: boolean;
    defaultValue: any | undefined;
    constraintTypes: string[] | undefined;
    bindingSourceId: string | undefined;
    descriptorName: string | undefined;
}

export class PermissionGrantInfoDto implements IPermissionGrantInfoDto {
    name!: string | undefined;
    displayName!: string | undefined;
    parentName!: string | undefined;
    isGranted!: boolean;
    allowedProviders!: string[] | undefined;
    grantedProviders!: ProviderInfoDto[] | undefined;

    constructor(data?: IPermissionGrantInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.parentName = _data["parentName"];
            this.isGranted = _data["isGranted"];
            if (Array.isArray(_data["allowedProviders"])) {
                this.allowedProviders = [] as any;
                for (let item of _data["allowedProviders"])
                    this.allowedProviders!.push(item);
            }
            if (Array.isArray(_data["grantedProviders"])) {
                this.grantedProviders = [] as any;
                for (let item of _data["grantedProviders"])
                    this.grantedProviders!.push(ProviderInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionGrantInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionGrantInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["parentName"] = this.parentName;
        data["isGranted"] = this.isGranted;
        if (Array.isArray(this.allowedProviders)) {
            data["allowedProviders"] = [];
            for (let item of this.allowedProviders)
                data["allowedProviders"].push(item);
        }
        if (Array.isArray(this.grantedProviders)) {
            data["grantedProviders"] = [];
            for (let item of this.grantedProviders)
                data["grantedProviders"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermissionGrantInfoDto {
    name: string | undefined;
    displayName: string | undefined;
    parentName: string | undefined;
    isGranted: boolean;
    allowedProviders: string[] | undefined;
    grantedProviders: ProviderInfoDto[] | undefined;
}

export class PermissionGroupDto implements IPermissionGroupDto {
    name!: string | undefined;
    displayName!: string | undefined;
    permissions!: PermissionGrantInfoDto[] | undefined;

    constructor(data?: IPermissionGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionGrantInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermissionGroupDto {
    name: string | undefined;
    displayName: string | undefined;
    permissions: PermissionGrantInfoDto[] | undefined;
}

export class PermissionOutput implements IPermissionOutput {
    grants!: string[] | undefined;
    allGrants!: string[] | undefined;
    permissions!: PermissionTreeDto[] | undefined;

    constructor(data?: IPermissionOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["grants"])) {
                this.grants = [] as any;
                for (let item of _data["grants"])
                    this.grants!.push(item);
            }
            if (Array.isArray(_data["allGrants"])) {
                this.allGrants = [] as any;
                for (let item of _data["allGrants"])
                    this.allGrants!.push(item);
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionTreeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.grants)) {
            data["grants"] = [];
            for (let item of this.grants)
                data["grants"].push(item);
        }
        if (Array.isArray(this.allGrants)) {
            data["allGrants"] = [];
            for (let item of this.allGrants)
                data["allGrants"].push(item);
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermissionOutput {
    grants: string[] | undefined;
    allGrants: string[] | undefined;
    permissions: PermissionTreeDto[] | undefined;
}

export class PermissionTreeDto implements IPermissionTreeDto {
    title!: string | undefined;
    key!: string | undefined;
    children!: PermissionTreeDto[] | undefined;

    constructor(data?: IPermissionTreeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.key = _data["key"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(PermissionTreeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionTreeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionTreeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["key"] = this.key;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermissionTreeDto {
    title: string | undefined;
    key: string | undefined;
    children: PermissionTreeDto[] | undefined;
}

export class ProfileDto implements IProfileDto {
    readonly extraProperties!: { [key: string]: any; } | undefined;
    userName!: string | undefined;
    email!: string | undefined;
    name!: string | undefined;
    surname!: string | undefined;
    phoneNumber!: string | undefined;
    isExternal!: boolean;
    hasPassword!: boolean;
    concurrencyStamp!: string | undefined;

    constructor(data?: IProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.phoneNumber = _data["phoneNumber"];
            this.isExternal = _data["isExternal"];
            this.hasPassword = _data["hasPassword"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): ProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key];
            }
        }
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["phoneNumber"] = this.phoneNumber;
        data["isExternal"] = this.isExternal;
        data["hasPassword"] = this.hasPassword;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IProfileDto {
    extraProperties: { [key: string]: any; } | undefined;
    userName: string | undefined;
    email: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    phoneNumber: string | undefined;
    isExternal: boolean;
    hasPassword: boolean;
    concurrencyStamp: string | undefined;
}

export class PropertyApiDescriptionModel implements IPropertyApiDescriptionModel {
    name!: string | undefined;
    jsonName!: string | undefined;
    type!: string | undefined;
    typeSimple!: string | undefined;
    isRequired!: boolean;

    constructor(data?: IPropertyApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.jsonName = _data["jsonName"];
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
            this.isRequired = _data["isRequired"];
        }
    }

    static fromJS(data: any): PropertyApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["jsonName"] = this.jsonName;
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        data["isRequired"] = this.isRequired;
        return data;
    }
}

export interface IPropertyApiDescriptionModel {
    name: string | undefined;
    jsonName: string | undefined;
    type: string | undefined;
    typeSimple: string | undefined;
    isRequired: boolean;
}

export class ProviderInfoDto implements IProviderInfoDto {
    providerName!: string | undefined;
    providerKey!: string | undefined;

    constructor(data?: IProviderInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.providerName = _data["providerName"];
            this.providerKey = _data["providerKey"];
        }
    }

    static fromJS(data: any): ProviderInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProviderInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["providerName"] = this.providerName;
        data["providerKey"] = this.providerKey;
        return data;
    }
}

export interface IProviderInfoDto {
    providerName: string | undefined;
    providerKey: string | undefined;
}

export class RegisterDto implements IRegisterDto {
    readonly extraProperties!: { [key: string]: any; } | undefined;
    userName!: string;
    emailAddress!: string;
    password!: string;
    appName!: string;

    constructor(data?: IRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.appName = _data["appName"];
        }
    }

    static fromJS(data: any): RegisterDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key];
            }
        }
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["appName"] = this.appName;
        return data;
    }
}

export interface IRegisterDto {
    extraProperties: { [key: string]: any; } | undefined;
    userName: string;
    emailAddress: string;
    password: string;
    appName: string;
}

export class RemoteServiceErrorInfo implements IRemoteServiceErrorInfo {
    code!: string | undefined;
    message!: string | undefined;
    details!: string | undefined;
    data!: { [key: string]: any; } | undefined;
    validationErrors!: RemoteServiceValidationErrorInfo[] | undefined;

    constructor(data?: IRemoteServiceErrorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.details = _data["details"];
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(RemoteServiceValidationErrorInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RemoteServiceErrorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteServiceErrorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["details"] = this.details;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = this.data[key];
            }
        }
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRemoteServiceErrorInfo {
    code: string | undefined;
    message: string | undefined;
    details: string | undefined;
    data: { [key: string]: any; } | undefined;
    validationErrors: RemoteServiceValidationErrorInfo[] | undefined;
}

export class RemoteServiceErrorResponse implements IRemoteServiceErrorResponse {
    error!: RemoteServiceErrorInfo;

    constructor(data?: IRemoteServiceErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"] ? RemoteServiceErrorInfo.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RemoteServiceErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteServiceErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRemoteServiceErrorResponse {
    error: RemoteServiceErrorInfo;
}

export class RemoteServiceValidationErrorInfo implements IRemoteServiceValidationErrorInfo {
    message!: string | undefined;
    members!: string[] | undefined;

    constructor(data?: IRemoteServiceValidationErrorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members!.push(item);
            }
        }
    }

    static fromJS(data: any): RemoteServiceValidationErrorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteServiceValidationErrorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item);
        }
        return data;
    }
}

export interface IRemoteServiceValidationErrorInfo {
    message: string | undefined;
    members: string[] | undefined;
}

export class ResetPasswordDto implements IResetPasswordDto {
    userId!: string;
    resetToken!: string;
    password!: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.resetToken = _data["resetToken"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetToken"] = this.resetToken;
        data["password"] = this.password;
        return data;
    }
}

export interface IResetPasswordDto {
    userId: string;
    resetToken: string;
    password: string;
}

export class ReturnValueApiDescriptionModel implements IReturnValueApiDescriptionModel {
    type!: string | undefined;
    typeSimple!: string | undefined;

    constructor(data?: IReturnValueApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
        }
    }

    static fromJS(data: any): ReturnValueApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnValueApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        return data;
    }
}

export interface IReturnValueApiDescriptionModel {
    type: string | undefined;
    typeSimple: string | undefined;
}

export class SendPasswordResetCodeDto implements ISendPasswordResetCodeDto {
    email!: string;
    appName!: string;
    returnUrl!: string | undefined;
    returnUrlHash!: string | undefined;

    constructor(data?: ISendPasswordResetCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.appName = _data["appName"];
            this.returnUrl = _data["returnUrl"];
            this.returnUrlHash = _data["returnUrlHash"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["appName"] = this.appName;
        data["returnUrl"] = this.returnUrl;
        data["returnUrlHash"] = this.returnUrlHash;
        return data;
    }
}

export interface ISendPasswordResetCodeDto {
    email: string;
    appName: string;
    returnUrl: string | undefined;
    returnUrlHash: string | undefined;
}

export class SettingItemOutput implements ISettingItemOutput {
    /** 名称 */
    name!: string | undefined;
    /** 显示名称 */
    displayName!: string | undefined;
    /** 描述 */
    description!: string | undefined;
    /** 值 */
    value!: string | undefined;
    /** 前端控件类型 */
    type!: string | undefined;

    constructor(data?: ISettingItemOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.value = _data["value"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): SettingItemOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SettingItemOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["value"] = this.value;
        data["type"] = this.type;
        return data;
    }
}

export interface ISettingItemOutput {
    /** 名称 */
    name: string | undefined;
    /** 显示名称 */
    displayName: string | undefined;
    /** 描述 */
    description: string | undefined;
    /** 值 */
    value: string | undefined;
    /** 前端控件类型 */
    type: string | undefined;
}

export class SettingOutput implements ISettingOutput {
    /** 分组 */
    group!: string | undefined;
    /** 分组显示名称 */
    groupDisplayName!: string | undefined;
    settingItemOutput!: SettingItemOutput[] | undefined;

    constructor(data?: ISettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.group = _data["group"];
            this.groupDisplayName = _data["groupDisplayName"];
            if (Array.isArray(_data["settingItemOutput"])) {
                this.settingItemOutput = [] as any;
                for (let item of _data["settingItemOutput"])
                    this.settingItemOutput!.push(SettingItemOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group;
        data["groupDisplayName"] = this.groupDisplayName;
        if (Array.isArray(this.settingItemOutput)) {
            data["settingItemOutput"] = [];
            for (let item of this.settingItemOutput)
                data["settingItemOutput"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISettingOutput {
    /** 分组 */
    group: string | undefined;
    /** 分组显示名称 */
    groupDisplayName: string | undefined;
    settingItemOutput: SettingItemOutput[] | undefined;
}

export class TenantCreateDto implements ITenantCreateDto {
    readonly extraProperties!: { [key: string]: any; } | undefined;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string;

    constructor(data?: ITenantCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.adminPassword = _data["adminPassword"];
        }
    }

    static fromJS(data: any): TenantCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key];
            }
        }
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        return data;
    }
}

export interface ITenantCreateDto {
    extraProperties: { [key: string]: any; } | undefined;
    name: string;
    adminEmailAddress: string;
    adminPassword: string;
}

export class TenantDto implements ITenantDto {
    readonly extraProperties!: { [key: string]: any; } | undefined;
    id!: string;
    name!: string | undefined;
    concurrencyStamp!: string | undefined;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key];
            }
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface ITenantDto {
    extraProperties: { [key: string]: any; } | undefined;
    id: string;
    name: string | undefined;
    concurrencyStamp: string | undefined;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    items!: TenantDto[] | undefined;
    totalCount!: number;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TenantDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface ITenantDtoPagedResultDto {
    items: TenantDto[] | undefined;
    totalCount: number;
}

export class TenantUpdateDto implements ITenantUpdateDto {
    readonly extraProperties!: { [key: string]: any; } | undefined;
    name!: string;
    concurrencyStamp!: string | undefined;

    constructor(data?: ITenantUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): TenantUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key];
            }
        }
        data["name"] = this.name;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface ITenantUpdateDto {
    extraProperties: { [key: string]: any; } | undefined;
    name: string;
    concurrencyStamp: string | undefined;
}

export class TimeZone implements ITimeZone {
    iana!: IanaTimeZone;
    windows!: WindowsTimeZone;

    constructor(data?: ITimeZone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iana = _data["iana"] ? IanaTimeZone.fromJS(_data["iana"]) : <any>undefined;
            this.windows = _data["windows"] ? WindowsTimeZone.fromJS(_data["windows"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TimeZone {
        data = typeof data === 'object' ? data : {};
        let result = new TimeZone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iana"] = this.iana ? this.iana.toJSON() : <any>undefined;
        data["windows"] = this.windows ? this.windows.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITimeZone {
    iana: IanaTimeZone;
    windows: WindowsTimeZone;
}

export class TimingDto implements ITimingDto {
    timeZone!: TimeZone;

    constructor(data?: ITimingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeZone = _data["timeZone"] ? TimeZone.fromJS(_data["timeZone"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TimingDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZone"] = this.timeZone ? this.timeZone.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITimingDto {
    timeZone: TimeZone;
}

export class TypeApiDescriptionModel implements ITypeApiDescriptionModel {
    baseType!: string | undefined;
    isEnum!: boolean;
    enumNames!: string[] | undefined;
    enumValues!: any[] | undefined;
    genericArguments!: string[] | undefined;
    properties!: PropertyApiDescriptionModel[] | undefined;

    constructor(data?: ITypeApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseType = _data["baseType"];
            this.isEnum = _data["isEnum"];
            if (Array.isArray(_data["enumNames"])) {
                this.enumNames = [] as any;
                for (let item of _data["enumNames"])
                    this.enumNames!.push(item);
            }
            if (Array.isArray(_data["enumValues"])) {
                this.enumValues = [] as any;
                for (let item of _data["enumValues"])
                    this.enumValues!.push(item);
            }
            if (Array.isArray(_data["genericArguments"])) {
                this.genericArguments = [] as any;
                for (let item of _data["genericArguments"])
                    this.genericArguments!.push(item);
            }
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(PropertyApiDescriptionModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TypeApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new TypeApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseType"] = this.baseType;
        data["isEnum"] = this.isEnum;
        if (Array.isArray(this.enumNames)) {
            data["enumNames"] = [];
            for (let item of this.enumNames)
                data["enumNames"].push(item);
        }
        if (Array.isArray(this.enumValues)) {
            data["enumValues"] = [];
            for (let item of this.enumValues)
                data["enumValues"].push(item);
        }
        if (Array.isArray(this.genericArguments)) {
            data["genericArguments"] = [];
            for (let item of this.genericArguments)
                data["genericArguments"].push(item);
        }
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITypeApiDescriptionModel {
    baseType: string | undefined;
    isEnum: boolean;
    enumNames: string[] | undefined;
    enumValues: any[] | undefined;
    genericArguments: string[] | undefined;
    properties: PropertyApiDescriptionModel[] | undefined;
}

export class UpdateConnectionStringInput implements IUpdateConnectionStringInput {
    id!: string;
    connectionString!: string;

    constructor(data?: IUpdateConnectionStringInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.connectionString = _data["connectionString"];
        }
    }

    static fromJS(data: any): UpdateConnectionStringInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateConnectionStringInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["connectionString"] = this.connectionString;
        return data;
    }
}

export interface IUpdateConnectionStringInput {
    id: string;
    connectionString: string;
}

export class UpdateEmailSettingsDto implements IUpdateEmailSettingsDto {
    smtpHost!: string | undefined;
    smtpPort!: number;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean;
    smtpUseDefaultCredentials!: boolean;
    defaultFromAddress!: string;
    defaultFromDisplayName!: string;

    constructor(data?: IUpdateEmailSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
        }
    }

    static fromJS(data: any): UpdateEmailSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEmailSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        return data;
    }
}

export interface IUpdateEmailSettingsDto {
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;
    defaultFromAddress: string;
    defaultFromDisplayName: string;
}

export class UpdateFeatureDto implements IUpdateFeatureDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: IUpdateFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdateFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IUpdateFeatureDto {
    name: string | undefined;
    value: string | undefined;
}

export class UpdateFeaturesDto implements IUpdateFeaturesDto {
    features!: UpdateFeatureDto[] | undefined;

    constructor(data?: IUpdateFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(UpdateFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateFeaturesDto {
    features: UpdateFeatureDto[] | undefined;
}

export class UpdatePermissionDto implements IUpdatePermissionDto {
    name!: string | undefined;
    isGranted!: boolean;

    constructor(data?: IUpdatePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isGranted = _data["isGranted"];
        }
    }

    static fromJS(data: any): UpdatePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        return data;
    }
}

export interface IUpdatePermissionDto {
    name: string | undefined;
    isGranted: boolean;
}

export class UpdatePermissionsDto implements IUpdatePermissionsDto {
    permissions!: UpdatePermissionDto[] | undefined;

    constructor(data?: IUpdatePermissionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(UpdatePermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdatePermissionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePermissionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdatePermissionsDto {
    permissions: UpdatePermissionDto[] | undefined;
}

export class UpdateProfileDto implements IUpdateProfileDto {
    readonly extraProperties!: { [key: string]: any; } | undefined;
    userName!: string | undefined;
    email!: string | undefined;
    name!: string | undefined;
    surname!: string | undefined;
    phoneNumber!: string | undefined;
    concurrencyStamp!: string | undefined;

    constructor(data?: IUpdateProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.phoneNumber = _data["phoneNumber"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): UpdateProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key];
            }
        }
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["phoneNumber"] = this.phoneNumber;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IUpdateProfileDto {
    extraProperties: { [key: string]: any; } | undefined;
    userName: string | undefined;
    email: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    phoneNumber: string | undefined;
    concurrencyStamp: string | undefined;
}

export class UpdateRoleInput implements IUpdateRoleInput {
    roleId!: string;
    roleInfo!: IdentityRoleUpdateDto;

    constructor(data?: IUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleInfo = _data["roleInfo"] ? IdentityRoleUpdateDto.fromJS(_data["roleInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleInfo"] = this.roleInfo ? this.roleInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateRoleInput {
    roleId: string;
    roleInfo: IdentityRoleUpdateDto;
}

export class UpdateRolePermissionsInput implements IUpdateRolePermissionsInput {
    providerName!: string;
    providerKey!: string;
    updatePermissionsDto!: UpdatePermissionsDto;

    constructor(data?: IUpdateRolePermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.providerName = _data["providerName"];
            this.providerKey = _data["providerKey"];
            this.updatePermissionsDto = _data["updatePermissionsDto"] ? UpdatePermissionsDto.fromJS(_data["updatePermissionsDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateRolePermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRolePermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["providerName"] = this.providerName;
        data["providerKey"] = this.providerKey;
        data["updatePermissionsDto"] = this.updatePermissionsDto ? this.updatePermissionsDto.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateRolePermissionsInput {
    providerName: string;
    providerKey: string;
    updatePermissionsDto: UpdatePermissionsDto;
}

export class UpdateSettingInput implements IUpdateSettingInput {
    values!: { [key: string]: string; } | undefined;

    constructor(data?: IUpdateSettingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key];
                }
            }
        }
    }

    static fromJS(data: any): UpdateSettingInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSettingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = this.values[key];
            }
        }
        return data;
    }
}

export interface IUpdateSettingInput {
    values: { [key: string]: string; } | undefined;
}

export class UpdateTenantInput implements IUpdateTenantInput {
    id!: string;
    name!: string;

    constructor(data?: IUpdateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateTenantInput {
    id: string;
    name: string;
}

export class UpdateUserInput implements IUpdateUserInput {
    userId!: string;
    userInfo!: IdentityUserUpdateDto;

    constructor(data?: IUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userInfo = _data["userInfo"] ? IdentityUserUpdateDto.fromJS(_data["userInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userInfo"] = this.userInfo ? this.userInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateUserInput {
    userId: string;
    userInfo: IdentityUserUpdateDto;
}

export class UserData implements IUserData {
    id!: string;
    tenantId!: string | undefined;
    userName!: string | undefined;
    name!: string | undefined;
    surname!: string | undefined;
    email!: string | undefined;
    emailConfirmed!: boolean;
    phoneNumber!: string | undefined;
    phoneNumberConfirmed!: boolean;

    constructor(data?: IUserData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.email = _data["email"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
        }
    }

    static fromJS(data: any): UserData {
        data = typeof data === 'object' ? data : {};
        let result = new UserData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        return data;
    }
}

export interface IUserData {
    id: string;
    tenantId: string | undefined;
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    email: string | undefined;
    emailConfirmed: boolean;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
}

export class UserDataListResultDto implements IUserDataListResultDto {
    items!: UserData[] | undefined;

    constructor(data?: IUserDataListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDataListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDataListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserDataListResultDto {
    items: UserData[] | undefined;
}

export class UserLoginInfo implements IUserLoginInfo {
    userNameOrEmailAddress!: string;
    password!: string;
    rememberMe!: boolean;

    constructor(data?: IUserLoginInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): UserLoginInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        return data;
    }
}

export interface IUserLoginInfo {
    userNameOrEmailAddress: string;
    password: string;
    rememberMe: boolean;
}

export class WindowsTimeZone implements IWindowsTimeZone {
    timeZoneId!: string | undefined;

    constructor(data?: IWindowsTimeZone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeZoneId = _data["timeZoneId"];
        }
    }

    static fromJS(data: any): WindowsTimeZone {
        data = typeof data === 'object' ? data : {};
        let result = new WindowsTimeZone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneId"] = this.timeZoneId;
        return data;
    }
}

export interface IWindowsTimeZone {
    timeZoneId: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}